<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022笔记本选购指南</title>
      <link href="//articles/2022/06/2022%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/"/>
      <url>//articles/2022/06/2022%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="2022年笔记本选购指南"><a href="#2022年笔记本选购指南" class="headerlink" title="2022年笔记本选购指南"></a>2022年笔记本选购指南</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>就我个人的经验来说<del>（这个经验也不一定准）</del>，笔记本一般品牌知名度越低性价比越高，质量也低。（清华同方）</p><p>一个好的笔记本不光要看电脑自身的cpu，显卡，内存，同时电脑的外观，屏幕素质，重量，散热等也是重要的考虑因素。</p><p>同时<strong>个人不推荐游戏本</strong>（血的教训），游戏本的重量一般2kg以上，同时正常运行有很大的散热噪音，如果不是电脑游戏爱好者不推荐游戏本。</p><p>对了，还有一种玩意叫移动工作站，性能怪兽（不是游戏性能），但用途太过专业，不做推荐。</p><p>下面对电脑的几个重要配件进行说明</p><p>不感兴趣可跳过</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>世界cpu有两大厂子：“intel”和“amd”，即蓝厂和红厂。</p><p>2019年之前，蓝厂一直吊打红厂，市面上很少有使用红厂cpu的电脑。</p><p>蓝厂见红厂怎么也赶不上自己，开始了“挤牙膏行为”</p><p>2019年前后是cpu历史一个重大转折点——红厂站起来了</p><p>曾经一度濒临倒闭的红厂，在使用7nm光刻技术与新技术后，把不思进取还在用12nm的蓝厂反超，于是出现了红厂cpu比蓝厂便宜还比他快的窘状。</p><p>现在红厂的cpu依然比蓝厂的性价比高。</p><p><del>AMD YES</del></p><p>现在还是尽量买amd cpu的电脑（即xxxxx锐龙版）</p><p>CPU有频率和核心数量两个概念，频率越大速度越快，核心数量理解为处理单元数量，6核心12线程相当于有12个处理器同时工作。</p><p>一般核心对电脑日常运行流畅度的贡献没有频率大。一个8核心3GHz的cpu不见得有6核心4GHz的处理器体验好。此外，电脑游戏非常吃频率，应尽量买频率高的CPU。</p><h3 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h3><blockquote><p>如果对电脑大型游戏没有需求，显卡不用太好。</p></blockquote><p>现在的显卡可分为核心显卡和独立显卡。核心显卡和cpu一体，是内置在cpu当中的，但是性能较为拉跨，为了运行大型游戏，需要一个额外的独立显卡，此类显卡性能比核心显卡高，可满足电脑游戏需求。</p><p>显卡厂商有英伟达和“amd”（绿厂和红厂）</p><p>两家显卡各有优劣，但英伟达性能更佳，amd一般是性价比之选</p><blockquote><p>红厂：“没错，还是我”</p></blockquote><p>显卡性能比较可参照显卡天梯图：</p><p><img src="https://pic2.zhimg.com/v2-361f2c0326db9b986aa795bb0f37e4bd_b.jpg" alt="enter image description here"></p><h3 id="运行内存"><a href="#运行内存" class="headerlink" title="运行内存"></a>运行内存</h3><p>这个一般没啥道道，尽量8G起步，越大越好，4G就有点卡了。</p><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>这玩意是水最深的，无良的资本家总是想进一步压缩成本，随着技术的不断改进，硬盘的质量，速度不断变差。关键是有的厂商质量变差的同时还不减价！</p><p>啥？变差？</p><p>技术改进，质量不该变好吗？别着急，听我慢慢道来。</p><p>打个比方，你有一张白纸，但你的笔很粗，特别粗，一张纸就能写一个字，你想写一篇200字的作文就需要200张纸，但你的字迹无比清晰好认。无良的资本家想，现在写一篇文章成本多高呀。</p><p>于是他们昼夜不息，研发出了更细的笔，现在一张纸可以写10个字了，写一篇文章的成本大大降低，但字体也变小。</p><p>他们觉得还不够，继续研发更细的笔，最后笔细得一张纸可以写10000个字，一张纸可以装好多篇文章了，但字体无比的小，极其难以阅读。</p><p>同样大小一张纸，一个上面只有一个字，另一个有10000个字，虽然空间利用率高了，但由于字变小，阅读效率大大降低。</p><p>这就是固态硬盘的发展趋势。其存储颗粒就可以类比于上面的纸。</p><div class="table-container"><table><thead><tr><th>颗粒名称</th><th>速度</th><th>质量</th><th>价格</th></tr></thead><tbody><tr><td>SLC</td><td>快</td><td>好</td><td>高</td></tr><tr><td>MLC</td><td>较快</td><td>较好</td><td>较高</td></tr><tr><td>TLC</td><td>慢</td><td>差</td><td>低</td></tr><tr><td>QLC</td><td>很慢</td><td>贼差</td><td>很低</td></tr></tbody></table></div><p>即SLC&gt;MLC&gt;TLC&gt;QLC</p><p>如果在网上看到有人说你看中的笔记本硬盘颗粒是QLC或TLC，基本上就要避雷了。</p><p>正常笔记本硬盘都是MLC的。</p><h3 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h3><p>这个玩意大家应该都挺清楚的，但还是要说一下。</p><p>刷新率一般60Hz足矣，在往上是游戏本配置。</p><p>分辨率越高越高</p><p>OLED好于LCD</p><p>LCD就是液晶屏幕，OLED类似于一个个小LED灯组成的，寿命较低，但色彩还原度高。</p><h3 id="散热"><a href="#散热" class="headerlink" title="散热"></a>散热</h3><p>这个要关注，笔记本在全功率运行时（比如玩大型游戏），发热十分严重，如果散热做的不好的话，运行不出期望中的速度，这个我也不会看，看中哪款可以上网上看相关评测。</p><h2 id="！！关于苹果的Mac笔记本！！"><a href="#！！关于苹果的Mac笔记本！！" class="headerlink" title="！！关于苹果的Mac笔记本！！"></a>！！关于苹果的Mac笔记本！！</h2><p><strong>不是单纯娱乐别买</strong></p><p>苹果在2020年推出了自研处理器M1，该处理器使用了不同于正常笔记本的处理器架构（ARM架构，正常电脑是X86)<del>但它确实快</del>，本质上相当于大号手机处理器，因此电脑软件必须通过转译才能运行，如果想给他装windows系统，那基本上不能正常使用，你日常用的windows版qq，网易云和游戏啥的基本上都运行不了或者速度大打折扣。你可以理解为苹果笔记本是电动汽车，传统笔记本是汽车，你人在非洲，你买电动汽车的话，你周围的基础设施不完善，汽车充不了电。苹果笔记本就类似这个处境，因此强烈不推荐。</p><p>ARM架构以后可能会成为笔记本发展的趋势，但现在处于时代变换的时刻，适用m1处理器软件尚不完善，还需几年的观望。</p><h2 id="价格定位"><a href="#价格定位" class="headerlink" title="价格定位"></a>价格定位</h2><p> 5k一下的电脑打一般大型游戏十分吃力。但完全胜任大学学习任务（对电脑使用频率高专业的还是卖贵点的心里来的舒畅）</p><p>5k~7k能打能用，十分推荐，但非游戏本打3A时的散热不大行，游戏爱好者可选，但慎重。也有性价比高的游戏本。</p><p>7k+w基本为游戏本和高端商务本，不推荐高端商务本。</p><h2 id="联想"><a href="#联想" class="headerlink" title="联想"></a>联想</h2><h3 id="联想小新pro14锐龙版"><a href="#联想小新pro14锐龙版" class="headerlink" title="联想小新pro14锐龙版"></a>联想小新pro14锐龙版</h3><p>4k-5k</p><p>理由：amd处理器（6核12线程，4.3GHz加速频率），性价比贼高</p><p>锐龙款有两个配置的，这个玩意没有独立显卡，因此更推荐搭载R7 6800H的款式，相较于R5 6600H的款式，R7 6800H的款式核芯显卡性能更高，速度也更快，性价比更高。</p><h3 id="联想小新pro16锐龙版"><a href="#联想小新pro16锐龙版" class="headerlink" title="联想小新pro16锐龙版"></a>联想小新pro16锐龙版</h3><p><strong>十分推荐 性价比贼高</strong></p><p>5k-7k</p><p>这个属于即能当小游戏本又可以工作的，价格浮动这么大主要是显卡，自己挺想尝试一下游戏可以试一试。</p><h3 id="拯救者R9000P"><a href="#拯救者R9000P" class="headerlink" title="拯救者R9000P"></a>拯救者R9000P</h3><p>7k-9k</p><p>之前我买拯救者的时候风评还没这么好，时代在进步。</p><p>缺点：沉</p><p>不过帅是真的帅，散热比较不错，屏幕也挺好，性价比不错，作为游戏本比较推荐</p><h2 id="华为Matebook"><a href="#华为Matebook" class="headerlink" title="华为Matebook"></a>华为Matebook</h2><p>性价比稍低，有良好的屏幕素质，还有一些手机上常用的玩意：指纹解锁，人脸识别等，体验很好，更重要的是，可以和<strong>华为手机多屏协同</strong>，因此不建议单飞。</p><p><strong>对了，华为笔记本不推荐触屏版，性价比低</strong></p><h2 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h2><h3 id="小米笔记本pro"><a href="#小米笔记本pro" class="headerlink" title="小米笔记本pro"></a>小米笔记本pro</h3><p>5k-6k</p><p>OLED显示屏（可能屏幕寿命会低一点，不过也到不了屏幕用坏的那一天），屏幕优秀，指纹解锁，和小米手机配合食用更佳，但打不了游戏。</p><h3 id="小米笔记本Pro-X"><a href="#小米笔记本Pro-X" class="headerlink" title="小米笔记本Pro X"></a>小米笔记本Pro X</h3><p>7k+</p><p>这玩意有游戏本的价格，游戏本的性能，但有着商务的外观，屏幕NB，挺高端。</p><p>RTX3050ti</p><h3 id="Redmi-G"><a href="#Redmi-G" class="headerlink" title="Redmi G"></a>Redmi G</h3><p>6k+</p><p>游戏本，性价比高，高刷新率，RTX3060。不到7k就能买到，散热给力，就是沉。</p><h2 id="华硕"><a href="#华硕" class="headerlink" title="华硕"></a>华硕</h2><p>品控好，超频设计优秀。</p><p>但是低端一点的屏幕和配置有缩水，不推荐。</p><h2 id="戴尔灵越，Latitude系列"><a href="#戴尔灵越，Latitude系列" class="headerlink" title="戴尔灵越，Latitude系列"></a>戴尔灵越，Latitude系列</h2><p>戴尔性价比出了名的低，不太推荐，但质量好</p><h2 id="戴尔外星人"><a href="#戴尔外星人" class="headerlink" title="戴尔外星人"></a>戴尔外星人</h2><p>1w~5w+</p><p>外星人游戏本在电脑中相当于球鞋中的AJ1，耳机中的Beats，衣服中的OFF-WHITE，汽车中的玛莎拉蒂。</p><p><code>讲个笑话：”外星人有性价比“</code></p><p>算了，不调侃了，总之这篇文章是推荐指南，实在想装X的也不是不行。</p><p>用途：游戏，装X。</p><h2 id="微软Surface"><a href="#微软Surface" class="headerlink" title="微软Surface"></a>微软Surface</h2><h2 id="pro-amp-amp-laptop"><a href="#pro-amp-amp-laptop" class="headerlink" title="pro &amp;&amp; laptop"></a>pro &amp;&amp; laptop</h2><p>7k-9k</p><p>不推荐，windows的触屏应用支持不完善，很多常用的应用不支持触屏或体验极差。</p><p>而且性价比低，8k的价格，5k的性能。</p><p>优点：500~600g的机身重量，便携性极高。</p><h2 id="1w"><a href="#1w" class="headerlink" title="1w+"></a>1w+</h2><p>能选1w+的笔记本说明经济没啥问题，此类笔记本没有大毛病，随便买。</p><p>没啥好推荐的，其实我无法推荐，看啥好买啥吧（不是Mac就行）。</p><p><del>不过建议试试amd3995wx+RTX3090ti</del></p><p><del>你问我多少钱？</del></p><p><del>5w吧</del></p><p><del>这只是CPU和显卡哦，其他的还没算呢</del></p><p><del>不够猛？试试3路cpu+8路显卡+128G内存+5T SLC硬盘+发烧级声卡+水冷+珍藏版机箱</del></p><p><del>也就相当于一辆宝马5系吧</del></p><blockquote><p><del>以后找女盆友</del></p><p><del>女盆友问你：“你有宝马吗？”</del></p><p><del>你回答：“我有3路amd3995wx8路RTX3090Ti128G内存5T<br>SLC硬盘发烧级声卡水冷+珍藏版机箱价值数十万的电脑。。。。。”</del></p><p><del>你对象一定会和你百年好合（大雾</del></p></blockquote><p>呵呵呵，机灵抖完了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>还有许多品牌没写到的，像惠普、荣耀啥的，主要是我了解的挺有限的，本文也仅供参考，对于电脑有一定的科普作用？</p><p>总之，每个电脑品牌都有自己的优势，价格差不多的话性能其实大差不差。自己想想需要什么，同时还要关注大学专业的选择，比如计算机专业推荐CPU性能高的笔记本。</p><p>最后，预祝大家都能考上自己理想的大学。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组的高级操作</title>
      <link href="//articles/2019/11/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%9A%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
      <url>//articles/2019/11/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%9A%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="单点修改，区间查询"><a href="#单点修改，区间查询" class="headerlink" title="单点修改，区间查询"></a>单点修改，区间查询</h2><p>题目：<a href="https://loj.ac/problem/130" target="_blank" rel="noopener">树状数组 1：单点修改，区间查询</a></p><p>很简单，就是运用了前缀和的思想，树状数组裸的板子，不多讲了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;#define endl &#39;\n&#39;#define lowbit(x) (x &amp; -x)#define R registerusing std::cin;using std::cout;int n, q;namespace treeArray{const int maxn = 1000006;long long a[maxn];inline void add(int pos, int x){    for (R int i = pos; i &lt;= n; i += lowbit(i))        a[i] += x;}inline long long sum(int pos){    long long ans = 0;    for (R int i = pos; i &gt;= 1; i -= lowbit(i))        ans += a[i];    return ans;}} // namespace treeArrayint main(){    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; q;    for (R int i = 1, x; i &lt;= n; i++)    {        cin &gt;&gt; x;        treeArray::add(i, x);    }    for (R int i = 1, c, l, r; i &lt;= q; i++)    {        cin &gt;&gt; c &gt;&gt; l &gt;&gt; r;        switch (c)        {        case 1:            treeArray::add(l, r);            break;        case 2:            cout &lt;&lt; treeArray::sum(r) - treeArray::sum(l - 1) &lt;&lt; endl;            break;        }    }    return 0;}</code></pre><h2 id="区间修改，单点查询"><a href="#区间修改，单点查询" class="headerlink" title="区间修改，单点查询"></a>区间修改，单点查询</h2><p>[题目]：<a href="https://loj.ac/problem/131" target="_blank" rel="noopener">树状数组 2 ：区间修改，单点查询</a></p><p>我们已经会了树状数组单点修改，区间查询辣，那么，区间修改，单点查询要怎么做呢？</p><p>说到区间查询我们能想到前缀和，那么区间修改呢——差分！！！</p><p>假设我们要把区间$l\sim r$加上$x$，根据差分的思想，我们只需要把$l\sim n$加上$x$，把$(r+1)\sim n$减去$x$就好了。</p><p>假如查询位置$p$的话，我们等于把$a<em>1\sim a_p$所有的值加起来。也就是$\sum</em>{i=1}^{p}a_i$。</p><p>我们只需要把树状数组维护的前缀和数组改成差分数组就好了。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;#define endl &#39;\n&#39;#define lowbit(x) (x &amp; -x)#define R registerusing std::cin;using std::cout;int n, q;namespace treeArray{const int maxn = 1000006;long long a[maxn];inline void add(int pos, int x){    for (R int i = pos; i &lt;= n; i += lowbit(i))        a[i] += x;}inline long long sum(int pos){    long long ans = 0;    for (R int i = pos; i &gt;= 1; i -= lowbit(i))        ans += a[i];    return ans;}} // namespace treeArrayint main(){    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; q;    for (R int i = 1, x, lx = 0; i &lt;= n; i++)  //差分    {        cin &gt;&gt; x;        treeArray::add(i, x - lx); //差分数组存的是两个元素之差        lx = x;    }    for (R int i = 1, c, l, r, x; i &lt;= q; i++)    {        cin &gt;&gt; c &gt;&gt; l;        switch (c)        {        case 1:            cin &gt;&gt; r &gt;&gt; x;            treeArray::add(l, x), treeArray::add(r + 1, -x);            break;        case 2:            cout &lt;&lt; treeArray::sum(l) &lt;&lt; endl;            break;        }    }    return 0;}</code></pre><h2 id="区间修改，区间查询"><a href="#区间修改，区间查询" class="headerlink" title="区间修改，区间查询"></a>区间修改，区间查询</h2><p>题目：<a href="https://loj.ac/problem/132" target="_blank" rel="noopener">树状数组 3 ：区间修改，区间查询</a></p><p>看到这个标题，您可能会想：什么，树状数组还有这种操作！！！线段树拜拜(。・∀・)ノ。</p><p>其实，<strong>树状数组也就只能到区间加减这个地步</strong>，它是不支持像线段树一样区间求$max$之类的运算的。但是遇到区间加减，区间查询的题目，树状数组还是能爆碾线段树的。</p><p>请见下图：</p><p><img src="/11/树状数组的高级操作/pc.jpg" alt="评测"> </p><p>这个东西其实是以区间修改，单点查询为基础的。</p><p>回放一下树状数组维护差分数组单点查询的公式：</p><script type="math/tex; mode=display">\sum_{i=1}^{p}a_i</script><p>假如我们查询$1\sim r$的值，我们只能暴力跑这个公式跑$r$遍，也就是：</p><script type="math/tex; mode=display">\sum_{i=1}^{r}\sum_{j=1}^{i}a_j</script><p>这个时候，我们发现，$a_1$被算了$r$次，$a_2$被算了$r-1$次，$a_3$被算了$r-2$次……</p><p>我们可以得到如下公式：</p><script type="math/tex; mode=display">\sum_{i=1}^{r}{\left(r-i+1\right)\times a_i}</script><script type="math/tex; mode=display">=\sum_{i=1}^{r}{\left(r+1\right)\times a_i-\sum_{i=1}^{r}{a_i\times i}}</script><p>我们开两个数组，一个存$a_i$，另一个存$a_i \times i$。</p><p>我们就可以用这个求辣。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;#define R register#define endl &#39;\n&#39;#define lowbit(x) x &amp; -xint n, p;namespace treeArray{const int maxn = 1000006;long long a1[maxn], a2[maxn];inline void add(int pos, long long x){    for (R int i = pos; i &lt;= n; i += lowbit(i))        a1[i] += x, a2[i] += pos * x;}inline long long sum(int pos){    long long ans = 0;    for (R int i = pos; i &gt;= 1; i -= lowbit(i))        ans += (pos + 1) * a1[i] - a2[i];    return ans;}} // namespace treeArrayint main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; p;    for (R int i = 1, x, lx = 0; i &lt;= n; i++)    {        cin &gt;&gt; x;        treeArray::add(i, x - lx);        lx = x;    }    for (R int i = 1, c, l, r, x; i &lt;= p; i++)    {        cin &gt;&gt; c &gt;&gt; l &gt;&gt; r;        switch (c)        {        case 1:            cin &gt;&gt; x;            treeArray::add(l, x), treeArray::add(r + 1, -x);            break;        case 2:            cout &lt;&lt; treeArray::sum(r) - treeArray::sum(l - 1) &lt;&lt; endl;            break;        }    }    return 0;}</code></pre><h2 id="end"><a href="#end" class="headerlink" title="$ end $"></a>$ end $</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 区间 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIPpj1998幂次方</title>
      <link href="//articles/2019/11/NOIPpj1998%E5%B9%82%E6%AC%A1%E6%96%B9/"/>
      <url>//articles/2019/11/NOIPpj1998%E5%B9%82%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下内容来自洛谷,<a href="https://www.luogu.org/problem/P1010" target="_blank" rel="noopener">P1010 幂次方</a></p></blockquote><div data-v-36666aac data-v-796309f8 data-v-af321868><!----> <h2 class="lfe-h2" data-v-af321868>题目描述</h2> <div class="marked" data-v-af321868 data-v-6156e5d2><p>任何一个正整数都可以用<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span>的幂次方表示。例如</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>137</mn><mo>=</mo><msup><mn>2</mn><mn>7</mn></msup><mo>+</mo><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">137=2^7+2^3+2^0 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></p><p>同时约定方次用括号来表示，即<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">a^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span></span> 可表示为<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span>。</p><p>由此可知，<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>137</mn></mrow><annotation encoding="application/x-tex">137</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span></span></span></span></span>可表示为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(7)+2(3)+2(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p><p>进一步：</p><p>7= 2^2+2+2^0$$  (2^1用2表示)，并且$$3=2+2^0</p><p>所以最后<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>137</mn></mrow><annotation encoding="application/x-tex">137</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span></span></span></span></span>可表示为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(2(2)+2+2(0))+2(2+2(0))+2(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p><p>又如：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1315</mn><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mo>+</mo><msup><mn>2</mn><mn>8</mn></msup><mo>+</mo><msup><mn>2</mn><mn>5</mn></msup><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1315=2^{10} +2^8 +2^5 +2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>所以<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1315</mn></mrow><annotation encoding="application/x-tex">1315</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span></span></span></span></span>最后可表示为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p></div> <h2 class="lfe-h2" data-v-af321868>输入格式</h2> <div class="marked" data-v-af321868 data-v-6156e5d2><p>一个正整数<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>≤</mo><mn>20000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n≤20000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>。</p></div> <h2 class="lfe-h2" data-v-af321868>输出格式</h2> <div class="marked" data-v-af321868 data-v-6156e5d2><p>符合约定的<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>的<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">0,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span></span>表示(在表示中不能有空格)</p></div> <!----> <h2 class="lfe-h2" data-v-af321868>输入输出样例</h2> <div class="sample-wrap sample" data-v-af321868 data-v-36768c72><div class="input" data-v-36768c72 data-v-89a1e792><strong data-v-89a1e792>输入 #1</strong> <button class="copy-btn lfe-form-sz-middle" style="border-color: rgb(52, 152, 219); color: rgb(52, 152, 219); background-color: rgba(52, 152, 219, 0);" type="button" data-v-f3e1ca6a data-v-89a1e792>    复制  </button> <pre data-v-89a1e792>1315</pre></div> <div class="output" data-v-36768c72 data-v-89a1e792><strong data-v-89a1e792>输出 #1</strong> <button class="copy-btn lfe-form-sz-middle" style="border-color: rgb(52, 152, 219); color: rgb(52, 152, 219); background-color: rgba(52, 152, 219, 0);" type="button" data-v-f3e1ca6a data-v-89a1e792>    复制  </button> <pre data-v-89a1e792>2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</pre></div></div> <!----></div><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是一道比较麻烦的橙题，考的是分治和数学？？。</p><p>我们说现需要明确的一点是任何一个数都可以被2的幂次方表示，所以不存在无解的情况。</p><p>有没有发现计算机内部也是用2的幂次方表示一个数的，所以我们可以使用二进制。<del>但我并不会。</del>所以我接下来讲的是另一种方法——</p><p>首先，我们要先求出一个2的幂次方与目标数最接近，之后对他们的差和求出来的指数继续进行如上操作，直到其指数小于等于2。</p><p>拿样例来举例：</p><p>假如我们要求$137$:</p><p>我们找到一个可以被2的幂次方表示出来的，和它最接近的数$127$，也就是$2^7$</p><p>而</p><script type="math/tex; mode=display">137-127=10</script><script type="math/tex; mode=display">7=2^2+2^1+2^0</script><script type="math/tex; mode=display">10=2^3+2^1</script><script type="math/tex; mode=display">2^3=2^1+2^0</script><p>所以答案为$137=2(2(2)+2+2(0))+2(2+2(0))+2(0)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;void work(int num){    cout &lt;&lt; &quot;2&quot;;    int i, x = 1;    for (i = 0; x &lt;= num; i++) //找不大于num最大的数        x *= 2;    x /= 2; //多算了一次    i--;    if (i &gt; 2) //指数大于2不合法，递归处理    {        cout &lt;&lt; &quot;(&quot;;        work(i);        cout &lt;&lt; &quot;)&quot;;    }    else    {        if (i == 2 or i == 0)            cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;)&quot;;    }    num -= x;    if (num) //如果还有剩余，继续处理    {        cout &lt;&lt; &quot;+&quot;;        work(num);    }}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n;    if(n == 0)  //0是无解的        return 0;    work(n);    return 0;}</code></pre><h2 id="end"><a href="#end" class="headerlink" title="end"></a><script type="math/tex">end</script></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2003神经网络</title>
      <link href="//articles/2019/11/NOIP2003%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>//articles/2019/11/NOIP2003%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>拓扑排序</p><a id="more"></a><p><a href="https://www.luogu.org/problem/P1038" target="_blank" rel="noopener">题目链接</a></p><blockquote><p>以下内容来自洛谷网</p></blockquote><div data-v-36666aac data-v-796309f8 data-v-af321868><h2 class="lfe-h2" data-v-af321868>题目背景</h2> <div class="marked" data-v-af321868 data-v-6156e5d2><p>人工神经网络（<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>a</mi><mi>l</mi><mi>N</mi><mi>e</mi><mi>u</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>N</mi><mi>e</mi><mi>t</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">Artificial Neural Network</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">e</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span>）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。</p></div> <h2 class="lfe-h2" data-v-af321868>题目描述</h2> <div class="marked" data-v-af321868 data-v-6156e5d2><p>在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：</p><p><img alt src="https://cdn.luogu.com.cn/upload/pic/13.png"> <img alt src="https://cdn.luogu.com.cn/upload/pic/58251.png"></p><p>神经元〔编号为<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>）</p><p>图中，<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>−</mo><msub><mi>X</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">X_1-X_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000002em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000002em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>是信息输入渠道，<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mn>1</mn></msub><mo>−</mo><msub><mi>Y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">Y_1-Y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000002em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000002em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>是信息输出渠道，<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000002em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>表示神经元目前的状态，<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000002em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>是阈值，可视为神经元的一个内在参数。</p><p>神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。</p><p><img alt src="https://cdn.luogu.com.cn/upload/pic/14.png">  <img alt src="https://cdn.luogu.com.cn/upload/pic/58252.png"></p><p>兰兰规定，<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000002em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>服从公式：（其中<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>是网络中所有神经元的数目）</p><p><img alt src="https://cdn.luogu.com.cn/upload/pic/15.png"></p><p><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><msub><mo>∑</mo><mrow><mo stretchy="false">(</mo><mi>j</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow></msub><msub><mi>W</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub><msub><mi>C</mi><mi>j</mi></msub><mo>−</mo><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i=\sum_{(j,i) \in E} W_{ji}C_{j}-U_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000002em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.22471em;vertical-align:-0.47471em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.22528999999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.47471em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000002em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000002em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000002em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>公式中的<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{ji}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000002em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>（可能为负值）表示连接<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></span>号神经元和<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>号神经元的边的权值。当 <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000002em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>大于<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span>时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000002em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>。</p><p>如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000002em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>），要求你的程序运算出最后网络输出层的状态。</p></div> <h2 class="lfe-h2" data-v-af321868>输入格式</h2> <div class="marked" data-v-af321868 data-v-6156e5d2><p>输入文件第一行是两个整数<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(1 \le n \le 100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>和<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span>。接下来<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>行，每行<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span>个整数，第<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>行是神经元<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>最初状态和其阈值（<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000002em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>），非输入层的神经元开始时状态必然为<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span>。再下面<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></span>行，每行由<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span>个整数<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></span>及<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>个整数<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000002em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>，表示连接神经元<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></span>的边权值为<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000002em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>。</p></div> <h2 class="lfe-h2" data-v-af321868>输出格式</h2> <div class="marked" data-v-af321868 data-v-6156e5d2><p>输出文件包含若干行，每行有<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span>个整数，分别对应一个神经元的编号，及其最后的状态，<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span>个整数间以空格分隔。仅输出最后状态大于<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span>的输出层神经元状态，并且按照编号由小到大顺序输出。</p><p>若输出层的神经元最后状态均为 <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span>，则输出 “NULL”。</p></div> <!----> <h2 class="lfe-h2" data-v-af321868>输入输出样例</h2> <div class="sample-wrap sample" data-v-af321868 data-v-36768c72><div class="input" data-v-36768c72 data-v-89a1e792><strong data-v-89a1e792>输入 #1</strong> <button class="copy-btn lfe-form-sz-middle" style="border-color: rgb(52, 152, 219); color: rgb(52, 152, 219); background-color: rgba(52, 152, 219, 0);" type="button" data-v-f3e1ca6a data-v-89a1e792>    复制  </button> <pre data-v-89a1e792>5 61 01 00 10 10 11 3 11 4 11 5 12 3 12 4 12 5 1</pre></div> <div class="output" data-v-36768c72 data-v-89a1e792><strong data-v-89a1e792>输出 #1</strong> <button class="copy-btn lfe-form-sz-middle" style="border-color: rgb(52, 152, 219); color: rgb(52, 152, 219); background-color: rgba(52, 152, 219, 0);" type="button" data-v-f3e1ca6a data-v-89a1e792>    复制  </button> <pre data-v-89a1e792>3 14 15 1</pre></div></div> <!----></div><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>读完题目后，发现出每个中间层的点都是由上一层的点的状态算出来的，于是可以轻松想到是拓扑排序。</p><p>注意，这个题目有以下坑点：</p><ol><li>根据题目可知，当一个神经元的兴奋值为负数，它就不可能向下传递了。这里要特判，<del>因为这个调了好久</del>。</li><li>输出时编号从小到大。</li><li>$u_i$在每次计算时只需要减一次。</li></ol><p>如果碰到出度为0并且状态是兴奋的点，就计入答案，最后排序。</p><p>提示：</p><ol><li>出度不需要单独计算，用邻接表的<code>head[]</code>数组便可。</li><li>非输入层的神经元开始时状态必然为$0$ (来自题目)。</li></ol><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><blockquote><p>代码应该很好懂，不写太多注释了。</p></blockquote><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 105;struct node{    int to, next, data;} edge[maxn * maxn &lt;&lt; 1];int head[maxn], num, n, p, rd[maxn], c[maxn], U[maxn];vector&lt;pair&lt;int, int&gt;&gt; ans;queue&lt;int&gt; q;inline void add(int from, int to, int data){    edge[++num] = (node){to, head[from], data};    head[from] = num;    rd[to]++; //计算入度}void toposort(){    while (!q.empty())    {        int u = q.front();        q.pop();        c[u] -= U[u];        if (head[u] == 0)            if (c[u] &gt; 0)                ans.push_back(make_pair(u, c[u]));        for (int i = head[u]; i; i = edge[i].next)        {            int to = edge[i].to;            if (c[u] &gt; 0) //如果它不是兴奋的就不能更新                c[to] += edge[i].data * c[u];            rd[to]--;            if (rd[to] == 0)                q.push(to);        }    }    if (ans.size() == 0)    {        cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl;        return;    }    sort(ans.begin(), ans.end());    for (int i = 0; i &lt; (int)ans.size(); i++)        cout &lt;&lt; ans[i].first &lt;&lt; &quot; &quot; &lt;&lt; ans[i].second &lt;&lt; endl;}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; p;    for (register int i = 1; i &lt;= n; i++)    {        cin &gt;&gt; c[i] &gt;&gt; U[i];        if (c[i] != 0)        {            U[i] = 0;            q.push(i);        }    }    for (register int i = 1, x, y, w; i &lt;= p; i++)    {        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        add(x, y, w);    }    toposort();    return 0;}</code></pre><h3 id="finish"><a href="#finish" class="headerlink" title="finish"></a><script type="math/tex">finish</script></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础数论笔记</title>
      <link href="//articles/2019/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
      <url>//articles/2019/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p></p><p><em>注意，本文不适合初学者阅读。适合有一定基础的盆友。</em></p><p></p><p></p><p><em>本文的“%”符号除特殊声明外，均指模运算，即mod</em></p><p></p><p></p><h3 id="欧几里得算法gcd">欧几里得算法（gcd）</h3><p></p><p></p><p>辗转相除法，用于求两个数的最大公约数。</p><p></p><h4 id="公式">公式：</h4><p><br><span class="math display">gcd (<em>a</em>,<em>b</em>) = <em>g</em><em>c</em><em>d</em>(<em>b</em>,<em>a</em> % <em>b</em>)</span><br></p><p>当<span class="math inline"><em>a</em> <em>m</em><em>o</em><em>d</em> <em>b</em> = 0</span>时，<span class="math inline"><em>b</em></span>便为我们要找的最大公约数</p><h4 id="代码">代码：</h4><pre><code class="lang-cpp">int gcd(int a, int b){    if(b == 0) return a;    return gcd(b, a % b);}</code></pre><p></p><h3 id="最小公倍数lcm">最小公倍数(lcm)</h3><p></p><h4 id="公式-1">公式：</h4><p><br><span class="math display"><em>a</em> × b ÷ <em>g</em><em>c</em><em>d</em>(<em>a</em>, <em>b</em>)</span><br></p><h3 id="扩展欧几里得算法exgcd">扩展欧几里得算法（exgcd）</h3><p>exgcd可以做以下事情：</p><ol type="1"><li><p>求解类似<span class="math inline">ax × <em>b</em><em>y</em> = <em>g</em><em>c</em><em>d</em>(<em>a</em>,<em>b</em>)</span>的一组可行解。</p></li><li><p>求逆元</p></li><li><p>求线性同余方程组的一组可行解。</p></li></ol><p><del>是不是很强大呢</del></p><h4 id="代码-1">代码：</h4><pre><code class="lang-cpp">int exgcd(int a, int b, int &amp;x ,int &amp;y){    if(b == 0)    {        x = 1;        y = 0;        return a;    }    int ans = exgcd(b, b % a); //顺便求gcd(a,b)的值       int tx = x;    x = y;    y = tx - a / b * y;    return ans;}</code></pre><p></p><h3 id="求解线性同余方程">求解线性同余方程</h3><p></p><p></p><p>形如这样的东东名叫线性同余方程：</p><p></p><p></p><p><br><span class="math display"><em>a</em><em>x</em> ≡ <em>c</em> (<em>m</em><em>o</em><em>d</em> <em>b</em>)</span><br></p><p></p><p></p><p>这个方程组等价于<span class="math inline"><em>a</em><em>x</em> + <em>b</em><em>y</em> = <em>c</em></span>，它有整数解的充要条件为<span class="math inline"><em>c</em> % <em>g</em><em>c</em><em>d</em>(<em>a</em>, <em>b</em>) = 0</span>。</p><p></p><p></p><p>我们可以用exgcd来求解。</p><p></p><p></p><p>我们先用exgcd求出<span class="math inline"><em>a</em><em>x</em> + <em>b</em><em>y</em> = <em>g</em><em>c</em><em>d</em>(<em>a</em>, <em>b</em>)</span>的一组解，之后等式两边同除<span class="math inline"><em>g</em><em>c</em><em>d</em>(<em>a</em>, <em>b</em>)</span>再乘上<span class="math inline"><em>c</em></span>，等式变成了：<span class="math inline"><em>a</em><em>x</em> ÷ <em>g</em><em>c</em><em>d</em>(<em>a</em>, <em>b</em>) × <em>c</em> + <em>b</em><em>x</em> ÷ <em>g</em><em>c</em><em>d</em>(<em>a</em>, <em>b</em>) × <em>c</em> = <em>c</em></span>，于是我们便求出了一组解。</p><p></p><h4 id="代码-2">代码：</h4><pre><code class="lang-cpp">int exgcd(int a, int b, int &amp;x, int &amp;y){    if (b == 0)    {        x = 1;        y = 0;        return a;    }    int ans = exgcd(b, b % a);    int tx = x;    x = y;    y = tx - a / b * y;    return ans;}void work(int a, int b, int c, int &amp;x, int &amp;y){    int d = exgcd(a, b, x, y);    if (c % d)        cout &lt;&lt; &quot;无整数解&quot;;    else    {        int k = c / d;        x *= k;        y *= k;    }}</code></pre><h4 id="关于求出的解是负数">关于求出的解是负数</h4><p>我们可以把答案不停的加上模数，直到它为正数为止，输出时候再取个模。</p><h3 id="逆元">逆元</h3><p>逆元是一类特殊的线性同余方程，形如<span class="math inline">ax ≡ 1(mod <em>b</em>)</span>且a和b互质，则称x是a在模b意义下的逆元，记作<span class="math inline"><em>a</em><sup> − 1</sup></span>。具体解法和求解线性同余方程基本一样，不再放代码了。</p><p>介绍一下费马小定理求逆元和线性递推。</p><h4 id="费马小定理">费马小定理</h4><p><em>以下内容来自百度百科。</em></p><blockquote><p>费马小定理(Fermat's little theorem)是<span class="underline">数论</span>中的一个重要<a href="https://baike.baidu.com/item/%E5%AE%9A%E7%90%86/9488549" target="_blank" rel="noopener"><span class="underline">定理</span></a>，在1636年提出。如果p是一个质数，而整数a不是p的倍数，则有<span class="math inline"><em>a</em><sup>（<em>p</em>−1）</sup> ≡ 1（mod <em>p</em>）</span></p></blockquote><p>我们可以发现<span class="math inline"><em>a</em><sup>（<em>p</em>−1）</sup> ≡ 1（mod <em>p</em>）</span>可以变成<span class="math inline"><em>a</em> × <em>a</em><sup><em>p</em> − 2</sup> ≡ 1(mod p)</span>。</p><p>所以<span class="math inline"><em>a</em><sup><em>p</em> − 2</sup></span>便是答案。</p>  <h4 id="线性递推求逆元">线性递推求逆元</h4><p>直接放代码(不太常用)：</p><p>a[i] = -(p/i) * a[p % i];</p><h3 id="卡特兰数">卡特兰数</h3><h4 id="公式-2">公式</h4><p><br><span class="math display">$$\sum_{i = 1}^{n}{f_{i - 1}f_{n - i}}$$</span><br></p><h4 id="代码-3">代码：</h4><pre><code class="lang-cpp">f[0] = 1, f[1] = 1;for (register int i = 2; i &lt;= n; i++){    for (register int j = 0; j &lt; i; j++)        f[i] += f[j] * f[i - j - 1];}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF722C-Destroying-Array题解</title>
      <link href="//articles/2019/11/CF722C-Destroying-Array/"/>
      <url>//articles/2019/11/CF722C-Destroying-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://codeforces.com/contest/722/problem/C" target="_blank" rel="noopener">点我传送</a></p><div><p>You are given an array consisting of <span class="tex-span"><i>n</i></span> non-negative integers <span class="tex-span"><i>a</i><sub class="lower-index">1</sub>, <i>a</i><sub class="lower-index">2</sub>, ..., <i>a</i><sub class="lower-index"><i>n</i></sub></span>.</p><p>You are going to destroy integers in the array one by one. Thus, you are given the permutation of integers from <span class="tex-span">1</span> to <span class="tex-span"><i>n</i></span> defining the order elements of the array are destroyed.</p><p>After each element is destroyed you have to find out the segment of the array, such that it contains no destroyed elements and the sum of its elements is maximum possible. The sum of elements in the empty segment is considered to be <span class="tex-span">0</span>.</p></div><div class="input-specification"><div class="section-title">Input</div><p>The first line of the input contains a single integer <span class="tex-span"><i>n</i></span> (<span class="tex-span">1 ≤ <i>n</i> ≤ 100 000</span>)&nbsp;— the length of the array.</p><p>The second line contains <span class="tex-span"><i>n</i></span> integers <span class="tex-span"><i>a</i><sub class="lower-index">1</sub>, <i>a</i><sub class="lower-index">2</sub>, ..., <i>a</i><sub class="lower-index"><i>n</i></sub></span> (<span class="tex-span">0 ≤ <i>a</i><sub class="lower-index"><i>i</i></sub> ≤ 10<sup class="upper-index">9</sup></span>). </p><p>The third line contains a permutation of integers from <span class="tex-span">1</span> to <span class="tex-span"><i>n</i></span>&nbsp;— the order used to destroy elements.</p></div><div class="output-specification"><div class="section-title">Output</div><p>Print <span class="tex-span"><i>n</i></span> lines. The <span class="tex-span"><i>i</i></span>-th line should contain a single integer&nbsp;— the maximum possible sum of elements on the segment containing no destroyed elements, after first <span class="tex-span"><i>i</i></span> operations are performed.</p></div><div class="sample-tests"><div class="section-title">Note</div><p>Consider the first sample: </p><ol> <li> Third element is destroyed. Array is now <span class="tex-span">1&nbsp;3&nbsp; * &nbsp;5</span>. Segment with maximum sum <span class="tex-span">5</span> consists of one integer <span class="tex-span">5</span>. </li><li> Fourth element is destroyed. Array is now <span class="tex-span">1&nbsp;3&nbsp; * &nbsp; * </span>. Segment with maximum sum <span class="tex-span">4</span> consists of two integers <span class="tex-span">1&nbsp;3</span>. </li><li> First element is destroyed. Array is now <span class="tex-span"> * &nbsp;3&nbsp; * &nbsp; * </span>. Segment with maximum sum <span class="tex-span">3</span> consists of one integer <span class="tex-span">3</span>. </li><li> Last element is destroyed. At this moment there are no valid nonempty segments left in this array, so the answer is equal to <span class="tex-span">0</span>. </li></ol></div><h3 id="以下内容来自bing翻译"><a href="#以下内容来自bing翻译" class="headerlink" title="以下内容来自bing翻译"></a>以下内容来自bing翻译</h3><p>‎您得到一个由‎‎n‎‎个非负整数组成的数组‎a1‎，a‎2‎，…， ‎n.<br>‎您将逐个销毁数组中的整数。因此，将为您提供从‎‎1‎‎到‎‎n‎‎的整数排列，定义数组的顺序元素将被销毁。‎<br>‎销毁每个元素后，您必须找出数组的段，以便它不包含任何已销毁的元素，并且其元素的总和是尽可能可能的。空段中的元素之和被视为‎‎0‎‎。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>正着做不好处理，那我们考虑倒着处理。</p><p>我们先假定这个序列是空的，之后每次把摧毁的数倒着加入序列，同时把它左右两边的数与它合并，顺便求一个$\max$，最后倒序输出答案便可。</p><p>用并查集实现。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 100005;int n, m, a[maxn], broken[maxn], fa[maxn];long long sum[maxn];bool tag[maxn];stack&lt;long long&gt; ans; //记录答案，因为是倒序输出，用栈可以方便点int find(int x) //并查集{    if (fa[x] == x)        return x;    return fa[x] = find(fa[x]);}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n;    for (register int i = 1; i &lt;= n; i++)    {        fa[i] = i;        cin &gt;&gt; a[i];        sum[i] = a[i];    //初始每个节点是独立的    }    for (register int i = 1; i &lt;= n; i++)        cin &gt;&gt; broken[i]; //被摧毁的数    ans.push(0);  //一开始序列是0    long long cnt = 0;    for (register int i = n; i &gt; 1; i--)    {        int now = broken[i], fnow = find(now);        tag[broken[i]] = true;    //这个元素被加入了序列        if (now &gt; 1 and tag[now - 1])  //判断左端点        {            int fz = find(now - 1);   //并查集合并            if (fz != fnow)            {                sum[now] += sum[fz];  //合并                sum[fz] = 0;  //清零                fa[fz] = now;            }        }        if (now &lt; n and tag[now + 1])  //判断右端点        {            int fz = find(now + 1);  //并查集合并            if (fz != fnow)            {                sum[now] += sum[fz]; //合并                sum[fz] = 0;  //清零                fa[fz] = now;            }        }        cnt = max(cnt, sum[now]);  //取最大值        ans.push(cnt);    }    while (n--)  //倒序输出答案    {        cout &lt;&lt; ans.top() &lt;&lt; endl;        ans.pop();    }    return 0;}</code></pre><h3 id="finish"><a href="#finish" class="headerlink" title="$finish$"></a>$finish$</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分图染色小记</title>
      <link href="//articles/2019/11/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2%E5%B0%8F%E8%AE%B0/"/>
      <url>//articles/2019/11/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="二分图染色"><a href="#二分图染色" class="headerlink" title="二分图染色"></a>二分图染色</h3><p>如果我们给一张图染色，相邻的点必须染上不同的颜色，对图进行染色的最小颜色数称为图的最小染色数。而最小颜色数为$2$的图则被称为”二分图‘’。</p><p>二分图的顶点和顶点之间的颜色一定不能相同，所以我们可以用染色的方法判定二分图。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>其实就一个DFS辣。</p><pre><code class="lang-cpp">/*------------邻接表---------------*/const int maxn = 10000;int head[maxn], num;struct node{    int to, next;} edge[maxn];inline void add_edge(int from, int to){    edge[++num] = (node){to, head[from]};    head[from] = num;}/*-------------二分图染色---------------*/int color[maxn];bool dfs(int u, int c){    color[u] = c; //染色    for (int i = head[u]; i; i = edge[i].next)    {        int to = edge[i].to;        if (color[to] == c) //相邻节点已被染上相同的颜色，证明这不是二分图            return false;        if (color[to] == 0 and !dfs(to, -c)) //如果未被染色，就染上相反的颜色            return false;                    //不合法，返回    }    return true;}void work(){    for (int i = 1; i &lt;= n; i++)        if (color[i] == 0 and dfs(i, 1))        {            cout &lt;&lt; &quot;不是二分图&quot; &lt;&lt; endl;            return;        }    cout &lt;&lt; &quot;是二分图 &quot; &lt;&lt; endl;}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.org/problem/P1330" target="_blank" rel="noopener">封锁阳光大学</a></p><details><summary>题解（展开）</summary><p>暴力二分图染色便可，一道模板。</p><p>早期的代码比较丑qwq</p><a href="https://www.luogu.org/paste/fq8yj3gj" target="_blank" rel="noopener">代码</a></details>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDOI2009]HH的项链题解</title>
      <link href="//articles/2019/11/SDOI2009-HH%E7%9A%84%E9%A1%B9%E9%93%BE%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/11/SDOI2009-HH%E7%9A%84%E9%A1%B9%E9%93%BE%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>离线+树状数组维护</p><a id="more"></a><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><a href="https://luogu.org/problem/P1972" target="_blank" rel="noopener">洛谷链接</a></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行：一个整数N，表示项链的长度。</p><p>第二行：N 个整数，表示依次表示项链中贝壳的编号（编号为0 到1000000 之间的整数）。</p><p>第三行：一个整数M，表示HH 询问的个数。</p><p>接下来M 行：每行两个整数，L 和R（1 ≤ L ≤ R ≤ N），表示询问的区间。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>M 行，每行一个整数，依次表示询问对应的答案。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>这题似乎可以用莫队？？？不过我不会QAQ</del></p><p>思路大致是这样的:</p><p>树状数组维护一个前缀和<code>f[i]</code>,代表从第一个位置到$i$个位置有多少个不同的数。</p><p>于是发现区间不同的值不好维护，我们可以把它离线下来。</p><p>我们按询问区间的右端点从小到大排序，之后从第一个数据开始处理。一旦后面的值和前面的值相同，那么在询问包含这个数的区间的时候，后面的值完全可以把前面的值替换掉。</p><p>例如</p><p><code>1 2 1 4 3 5</code></p><ol><li>在第1位插入<code>1</code>(表示第一位有一个不一样的数)，标记<code>1</code></li><li>在第2位插入<code>1</code>，标记<code>2</code></li><li>在第3位插入<code>1</code>，发现已被标记，于是清除第一位的<code>1</code></li><li>询问1~3，<code>sum(3) - sum(0)</code></li></ol><p>因为我们询问的区间已按右端点排过序，所以询问的区间不管包不包含已删掉的元素，答案都只被最后一个相同的元素影响。</p><p>有点啰嗦了，感性理解一下吧。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define endl &#39;\n&#39;#define R register#define lowbit(x) x &amp; -xusing std::cin;using std::cout;const int maxn = 1000005;int a[maxn], b[maxn], n;int next = 1, vis[maxn], ans[maxn], m;inline void add(int pos, int x){    for (R int i = pos; i &lt;= n; i += lowbit(i))        a[i] += x;}inline int sum(int pos){    int ans = 0;    for (R int i = pos; i &gt; 0; i -= lowbit(i))        ans += a[i];    return ans;}struct ask{    int l, r, pos;    bool operator&lt;(const ask &amp;b) const    {        return r &lt; b.r;    }} q[maxn];int main(){    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n;    for (R int i = 1; i &lt;= n; i++)        cin &gt;&gt; b[i];    cin &gt;&gt; m;    for (R int i = 1; i &lt;= m; i++)    {        cin &gt;&gt; q[i].l &gt;&gt; q[i].r;        q[i].pos = i; //记录这个询问的位置    }    std::sort(q + 1, q + m + 1);    for (R int i = 1; i &lt;= m; i++)    {        for (R int j = next; j &lt;= q[i].r; j++)        {            if (vis[b[j]])                add(vis[b[j]], -1);  //打上-1是清零：1 + (-1)=0            vis[b[j]] = j;            add(j, 1);        }        ans[q[i].pos] = sum(q[i].r) - sum(q[i].l - 1); //离线计算答案        next =    q[i].r + 1;    }    for (R int i = 1; i &lt;= m; i++)        cout &lt;&lt; ans[i] &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂学习笔记</title>
      <link href="//articles/2019/11/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>//articles/2019/11/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>接下来讲的快速幂并非二进制版本，而是<code>二分幂</code></p><a id="more"></a><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>有些时候，我们需要求一个数的多次幂，假如数字非常大，这个时候，手写的求幂函数和<code>cmath</code>库中自带的<code>pow</code>函数就显得有些慢了。接下来我要讲一种算法可以在$O(\log n)$的时间内求出一个数的多次幂。</p><p>翻翻初中数学课本，我们可以发现如下公式：</p><script type="math/tex; mode=display">x^y \times x^z = x^{y+z}</script><p>应用到OI上来，因为<code>C++ int</code>有精度误差，所以我们要分情况讨论。</p><p>如果$y$是偶数：</p><script type="math/tex; mode=display">x^y = x^{\lfloor \frac y 2 \rfloor  + \lfloor \frac y 2 \rfloor} = x^{\lfloor \frac y 2 \rfloor} \times x^{\lfloor \frac y 2 \rfloor}</script><p>如果$y$是奇数：</p><script type="math/tex; mode=display">x^y = x^{\lfloor \frac y 2 \rfloor} \times x^{\lfloor \frac y 2 \rfloor} \times x</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">int slow_pow(int x, int y){    int ans = 1;    while (y &gt; 0)    {        if (y % 1 == 1)            ans = ans * x;        x = x * x;        y /= 2;    }    return ans;}</code></pre><h3 id="例题-NOIP2013-转圈游戏"><a href="#例题-NOIP2013-转圈游戏" class="headerlink" title="例题 NOIP2013 转圈游戏"></a>例题 NOIP2013 转圈游戏</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><a href="https://loj.ac/problem/2608" target="_blank" rel="noopener">点我传送</a></p><p>$ n$ 个小伙伴（编号从 $ 0$ 到$ n-1$ ）围坐一圈玩游戏。按照顺时针方向给 $ n$ 个位置编号，从$ 0$  到 $ n-1$ 。最初，第 $ 0$ 号小伙伴在第 $0$ 号位置，第 $1$ 号小伙伴在第 $ 1$  号位置，……，依此类推。游戏规则如下：每一轮第$  0$ 号位置上的小伙伴顺时针走到第$ m$  号位置，第 $ 1$ 号位置小伙伴走到第$  m+1$  号位置，……，依此类推，第$ n − m$ 号位置上的小伙伴走到第 $ 0$  号位置，第$ n \sim m+1$  号位置上的小伙伴走到第$ 1$  号位置，……，第$ n-1$  号位置上的小伙伴顺时针走到第$ m-1$  号位置。</p><p>现在，一共进行了 $ 10^k$ 轮，请问xx 号小伙伴最后走到了第几号位置。</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>我们不难推出以下“柿子”：</p><script type="math/tex; mode=display">(m \times 10 ^k + x) \mod n</script><p>一个快速幂搞定。</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;using std::cin;using std::cout;#define endl &#39;\n&#39;#define R registerlong long n, m, k, x;long long _pow(long long y, long long x,long long mod){    long long ans = 1;    while(x &gt; 0)    {        if(x &amp; 1)            ans = ans * y % mod;        y = y * y % mod;        x &gt;&gt;= 1;    }    return ans % mod;}int main(){#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);#endif    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; x;    cout &lt;&lt; (m % n * _pow(10, k, n) % n + x % n) % n;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018对称二叉树</title>
      <link href="//articles/2019/11/NOIP2018%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>//articles/2019/11/NOIP2018%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>太长，直接放洛谷链接：</p><p><a href="https://www.luogu.org/problem/P5018" target="_blank" rel="noopener">https://www.luogu.org/problem/P5018</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>棉花糖还我省一！！！</del></p><p>这题是NOIP2018PJ第四题，考场上T3没推出来，加上食物中毒，导致T4这么一个水搜索没写完。</p><p>如果一棵树是对称的。那么对于下图的根节点，它的两个子节点(紫色)的一定要是对称的，那么对于这两个子节点，左边子节点的右儿子一定要和右边节点的左儿子对称(红色)，同理，左边子节点的左儿子一定要和右边节点的右儿子对称(橙色)。</p><p><img src="/11/NOIP2018对称二叉树/批注182546.jpg" alt="1"></p><p>我们只要以每个节点为根，遍历一遍它的子树，如果是对称的，则计入答案，最后取个$\max$便可。</p><p>时间复杂度：$O(n\log n)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;using std::cout;using std::cin;/*-----------变量定义、宏定义-------------*/#define endl &#39;\n&#39;#define R register#define max(a, b) a &gt; b ? a : bconst int maxn = 1000006;//v存每个节点的子节点数量int n, ans, v[maxn];struct node{    int lson, rson, data;}z[maxn];/*-----------子函数--------------*/bool check(int rt1,int rt2) //判断是否对称{    if (rt1 == -1 and rt2 == -1) return true; //如果是单个节点，一定满足对称    if (z[rt1].data != z[rt2].data or rt1 == -1 or rt2 == -1)        return false; //左儿子右儿子不一样一定不满足    int v1 = check(z[rt1].lson, z[rt2].rson);    int v2 = check(z[rt1].rson, z[rt2].lson);    if (!v1 or !v2) return false; //左子树右子树有一个不对称则一定不对称    return true; //否则是对称的}void sum(int rt)  //预处理子节点的数量{    if (rt == -1) return;    sum(z[rt].lson);    sum(z[rt].rson);    v[rt] += 1 + v[z[rt].lson] + v[z[rt].rson];}void dfs(int rt)  //每个点都试一遍{    if (rt == -1) return;    if (check(z[rt].lson, z[rt].rson))        ans = max(ans, v[rt]);    dfs(z[rt].lson);    dfs(z[rt].rson);}/*-----------主函数--------------*/int main(){    std::ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n;    for (R int i = 1; i &lt;= n; ++i)        cin &gt;&gt; z[i].data;    for (R int i = 1; i &lt;= n; i++)        cin &gt;&gt; z[i].lson &gt;&gt; z[i].rson;    sum(1);  //预处理    dfs(1);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><h3 id="NOIP2018-IS-END"><a href="#NOIP2018-IS-END" class="headerlink" title="NOIP2018 IS END"></a>NOIP2018 IS END</h3>]]></content>
      
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分约束系统学习笔记</title>
      <link href="//articles/2019/10/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>//articles/2019/10/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>差分约束系统由<code>n</code>个形如$x+y\leq z$的不等式组成，<strong>注意：这里<code>x</code>和<code>y</code>是常数</strong>。</p><blockquote><p>差分约束系统（System of Difference Constraints），是求解关于一组变数的特殊不等式组之方法。<br>如果一个系统由${\displaystyle n}$个变量和${\displaystyle m}$个约束条件组成，其中每个约束条件形如${\displaystyle x<em>{j}-x</em>{i}\leq b_{k}(i,j\in [1,n],k\in [1,m])}$,则称其为差分约束系统。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。 　　—维基百科</p></blockquote><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>我们可以把差分约束系统转换为图论中的最短路径来求解，我们来看一下下面的的不等式：</p><script type="math/tex; mode=display">x-y \geq z</script><p>可以发现它和图论中的三角不等式极其相似</p><script type="math/tex; mode=display">dis_x + w_{x,y} \geq dis_y</script><p>它相当于</p><script type="math/tex; mode=display">w_{u,v} \geq dis_y- dis_x</script><p><strong>注意：这里x和y是常数</strong></p><p>我们把<code>x</code>和<code>y</code>看作点，<code>z</code>看作边权，所以我们要连一条$y \to x$，边权为$z$的边。</p><p>如果不等式符号相反。例如：</p><script type="math/tex; mode=display">x-y\leq z</script><p>它可以变形为:</p><script type="math/tex; mode=display">y-x \geq -z</script><p>我们从<code>x</code>向<code>y</code>连一条边权为<code>-z</code>的边即可。</p><p>在建完图后，跑一遍最短路算法便可，<code>Dijkstra</code>不能处理有负边权的图，所以我们要使用<code>SPFA</code>算法。<strong>SPFA带SLF优化会被负权图卡成指数级。</strong></p><p>如果图不连通或者出现了负权回路则说明差分约束系统无解。</p><h3 id="SPFA模板"><a href="#SPFA模板" class="headerlink" title="SPFA模板"></a>SPFA模板</h3><pre><code class="lang-cpp">void SPFA(int x){    queue&lt;int&gt; q;    dis[x] = 0;    vis[x] = true;    q.push(x);    while (!q.empty())    {        int u = q.front();        q.pop();        vis[u] = false;        for (int i = head[u]; i; i = edge[i].next)        {            int v = edge[i].to;            if (dis[v] &gt; dis[u] + edge[i].data)            {                dis[v] = dis[u] + edge[i].data;                if (++cnt[v] &gt;= n) //出现负权回路                {                    puts(&quot;-1&quot;);                    exit(0);                }                if (vis[v] == false)                {                    q.push(v);                    vis[v] = true;                }            }        }    }}</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.org/problem/P1993" target="_blank" rel="noopener">小K的农场</a></p><p><a href="https://www.luogu.org/problem/P4878" target="_blank" rel="noopener">USACO05DEC 布局</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 图论 </tag>
            
            <tag> SPFA </tag>
            
            <tag> 差分约束系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2012借教室</title>
      <link href="//articles/2019/10/NOIP2012%E5%80%9F%E6%95%99%E5%AE%A4/"/>
      <url>//articles/2019/10/NOIP2012%E5%80%9F%E6%95%99%E5%AE%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。</p><p>面对海量租借教室的信息，我们自然希望编程解决这个问题。</p><p>我们需要处理接下来$n$天的借教室信息，其中第ii天学校有$r_i$<br>​     个教室可供租借。共有$m$份订单，每份订单用三个正整数描述，分别为$d_j,s_j,t_j$ ，表示某租借者需要从第$s_j$天到第$t_j$天租借教室（包括第$s_j$天和第$t_j$天），每天需要租借$d_j$个教室。</p><p>我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$d_j$个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p><p>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$s_j$天到第$t_j$天中有至少一天剩余的教室数量不足$d_j$个。</p><p>现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p><p>输入格式<br>第一行包含两个正整数$n,m$，表示天数和订单的数量。</p><p>第二行包含$n$个正整数，其中第$i$个数为$r_i$<br>​     ，表示第$i$天可用于租借的教室数量。</p><p>接下来有$m$行，每行包含三个正整数$d_j,s_j,t_j$，表示租借的数量，租借开始、结束分别在第几天。</p><p>每行相邻的两个数之间均用一个空格隔开。天数与订单均用从$1$开始的整数编号。</p><p>输出格式<br>如果所有订单均可满足，则输出只有一行，包含一个整数$0$。否则（订单无法完全满足）</p><p>输出两行，第一行输出一个负整数$-1$，第二行输出需要修改订单的申请人编号。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目看了一半的时候以为是二分答案，后来。。。。</p><p><strong>这不就是个线段树么</strong></p><p>题意很明确，让你维护一个区间，每次给这段区间加上1，之后判断它的值是否超出了给定的界限。</p><p>这样维护很麻烦，我们可以逆向操作。</p><p>先给线段树赋上最大租借的教室数，之后区间减一，一旦有一个数小于零的话，说明教室不够了，输出便可。</p><h3 id="代码（这次线段树写的比较毒瘤）"><a href="#代码（这次线段树写的比较毒瘤）" class="headerlink" title="代码（这次线段树写的比较毒瘤）"></a>代码<del>（这次线段树写的比较毒瘤）</del></h3><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;namespace my{#define lson l, mid, rt &lt;&lt; 1#define rson mid + 1, r, rt &lt;&lt; 1 | 1#define maxn 2000006class segmentTree{public:    void build(int l, int r, int rt);    void modify(int l, int r, int rt, int fl, int fr, int x);    inline int find();private:    inline int min(int x, int y);    inline void update(int rt);    inline void add(int l, int r, int rt, int x);    inline void push(int l, int r, int rt);    int z[maxn], tag[maxn];};inline int segmentTree::min(int x, int y){    return x &gt; y ? y : x;}void segmentTree::build(int l, int r, int rt){    if(l == r)    {        cin &gt;&gt; z[rt];        return;    }    int mid = (l + r) &gt;&gt; 1;    build(lson);    build(rson);    update(rt);}inline void segmentTree::update(int rt){    z[rt] = min(z[rt &lt;&lt; 1], z[rt &lt;&lt; 1 | 1]);}void segmentTree::modify(int l, int r, int rt, int fl, int fr, int x){    if(l == fl and fr == r)    {        add(l, r, rt, x);        return;    }    push(l, r, rt);    int mid = (l + r) &gt;&gt; 1;    if(fl &lt;= mid)    {        if(fr &gt; mid) modify(lson, fl, mid, x), modify(rson, mid + 1, fr, x);        else modify(lson, fl, fr, x);    }    else        modify(rson, fl, fr, x);    update(rt);}inline int segmentTree::find(){    return z[1];}inline void segmentTree::add(int l, int r, int rt, int x){    z[rt] -= x;    tag[rt] += x;}inline void segmentTree::push(int l, int r, int rt){    if(tag[rt])    {        int mid = (l + r) &gt;&gt; 1;        add(lson, tag[rt]);        add(rson, tag[rt]);        tag[rt] = 0;    }}#undef lson#undef rson#undef maxn}my::segmentTree t;int n, m, d, l, r;int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; m;    t.build(1, n, 1);    for(register int i = 1; i &lt;= m ;i++)    {        cin &gt;&gt; d &gt;&gt; l &gt;&gt; r;        t.modify(1, n, 1, l, r, d);        if(t.find() &lt; 0)        {            cout &lt;&lt; &quot;-1\n&quot; &lt;&lt; i &lt;&lt; endl;            return 0;        }    }    cout &lt;&lt; &quot;0&quot;;    return 0;}</code></pre><h3 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 区间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形DP-没有上司的舞会题解</title>
      <link href="//articles/2019/10/%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/10/%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>树形DP入门题</p><a id="more"></a> <h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目描述<br>某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p><p>输入格式<br>第一行一个整数N。(1&lt;=N&lt;=6000)</p><p>接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128&lt;=Ri&lt;=127)</p><p>接下来N-1行，每行输入一对整数L,K。表示K是L的直接上司。</p><p>最后一行输入0 0</p><p>输出格式<br>输出最大的快乐指数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这可能是一道最简单的树形DP题目了。</p><p>我用的是邻接矩阵存树，$a[i][j]$代表$i$是$j$的上司。</p><p>我们设$f[i][j]$表示第$j$个人来不来参加舞会。$i$为true代表来参加，false代表不来参加。</p><p>对于每一个人，如果他的下属们来参加，便有：</p><p>他自己一定不能来，否则冲突，下属可以来也可以不来，所以有三种情况</p><script type="math/tex; mode=display">f[1][j] = \max(f[1][j],f[1][j] + f[0][i],f[0][i])</script><p>若下属不来：</p><p>他的上司可以来也可以不来，所以也有三种情况</p><script type="math/tex; mode=display">f[0][j] = \max(f[0][j], f[1][i] + f[0][j], f[1][i]);</script><p>我们找到树根，一遍DP就行。</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#define maxn 6005using namespace std;int n, v[maxn] = {}, x, y;int a[maxn][maxn] = {};int f[3][maxn] = {};int root[maxn] = {};void dfs(int x){    for (register int i = 1; i &lt;= n; i++)        if (a[i][x])        {            dfs(i);            f[0][x] = max(max(f[0][x], f[1][i] + f[0][x]), f[1][i]);            f[1][x] = max(max(f[1][x], f[0][i] + f[1][x]), f[0][i]);        }}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n;    for (register int i = 1; i &lt;= n; i++)        cin &gt;&gt; f[1][i];    for (register int i = 1; i &lt; n; i++)    {        cin &gt;&gt; x &gt;&gt; y;        root[x] = 1;        a[x][y] = 1;    }    int r;    for (register int i = 1; i &lt;= n; i++)        if (!root[i])        {            r = i;            break;        }    dfs(r);    cout &lt;&lt; max(f[1][r], f[0][r]) &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF135B-Rectangle-and-Square题解</title>
      <link href="//articles/2019/10/CF135B-Rectangle-and-Square%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/10/CF135B-Rectangle-and-Square%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>暴力枚举，一道水灰</p><a id="more"></a><p><a href="https://www.luogu.org/problem/CF135B" target="_blank" rel="noopener">luogu链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Little Petya very much likes rectangles and especially squares. Recently he has received 8 points on the plane as a gift from his mother. The points are pairwise distinct. Petya decided to split them into two sets each containing 4 points so that the points from the first set lay at the vertexes of some square and the points from the second set lay at the vertexes of a rectangle. Each point of initial 8 should belong to exactly one set. It is acceptable for a rectangle from the second set was also a square. If there are several partitions, Petya will be satisfied by any of them. Help him find such partition. Note that the rectangle and the square from the partition should have non-zero areas. The sides of the figures do not have to be parallel to the coordinate axes, though it might be the case.</p><p>Input<br>You are given 8 pairs of integers, a pair per line — the coordinates of the points Petya has. The absolute value of all coordinates does not exceed 104. It is guaranteed that no two points coincide.</p><p>Output<br>Print in the first output line “YES” (without the quotes), if the desired partition exists. In the second line output 4 space-separated numbers — point indexes from the input, which lie at the vertexes of the square. The points are numbered starting from 1. The numbers can be printed in any order. In the third line print the indexes of points lying at the vertexes of a rectangle in the similar format. All printed numbers should be pairwise distinct.</p><p>If the required partition does not exist, the first line should contain the word “NO” (without the quotes), after which no output is needed.</p><h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><p>给你八个点，问这八个点能否恰好构成一个正方形和一个矩形。</p><p>输出文件第一行是”YES”或者”NO”。表示是否有解。</p><p>若有解则第二行依次输出正方形每个顶点的序号。第三行依次输出矩形每个顶点的序号。序号即为输入的顺序。</p><p>第二行和第三行这八个数要字典序最小。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>数据范围不大，暴力枚举每个点即可 </p><p>时间复杂度$O(1)$ <del>常数有点大233</del></p><p><strong><em>对于矩形的判定：</em></strong></p><p><del>复习初中内容（</del></p><p>我们有这么一个几何图形：</p><p><img src="/10/CF135B-Rectangle-and-Square题解/1.png" alt="1"></p><p>要证明它是一个矩形，先要证明它是平行四边形，所以它的对边要相等。</p><p><img src="/10/CF135B-Rectangle-and-Square题解/2.png" alt="2"></p><p>对于一个平行四边形，我们只需要证明它的其中一个角是直角便可证明他是矩形。</p><p><del>我比较菜，不会什么叉积。</del></p><p>我们只需使用 <em>勾股逆定理</em> 便可</p><blockquote><p>如果三角形两条边的平方和等于第三边的平方，那么这个三角形就是直角三角形。最长边所对的角为直角</p></blockquote><p><img src="/10/CF135B-Rectangle-and-Square题解/3.png" alt="3"></p><script type="math/tex; mode=display">a^2 + b^2 = c^2</script><p>而</p><script type="math/tex; mode=display">a = (y_k - y_i)^2 + (x_k-x_i)^2</script><script type="math/tex; mode=display">b = (y_i - y_k)^2 + (x_j-x_i)^2</script><script type="math/tex; mode=display">c = (y_k - y_j)^2 + (x_k-x_j)^2</script><p>对于 <strong><em>正方形</em></strong> ，我们只需证明它是 <strong><em>临边相等</em></strong> 即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define n 8#define ix star[i].x#define jx star[j].x#define kx star[k].x#define lx star[l].x#define iy star[i].y#define jy star[j].y#define ky star[k].y#define ly star[l].y#define fors(a,c) for(register int a=1;a&lt;=c;a++)//对边是否相等#define cube1 (iy - jy) ==  (ly - ky) and  (lx - ix) ==  (kx - jx)//临边是否相等#define cube2 pow((iy-jy),2) + pow((jx-ix),2) == pow((ly - iy),2) + pow((lx-ix),2)//四个点连成一条线是不合法的欧#define other  ky != jy and  jx !=  ix//是否有直角#define zhijiao  pow((iy-jy),2) +  pow((jx-ix),2) +  pow((ly - iy),2) +  pow((lx-ix),2) ==  pow((lx-jx),2) +  pow((ly-jy),2)using namespace std;struct S{    int x, y;} star[10];bool done, vis[10];vector&lt;int&gt; v, v1;int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    fors(i, n)    cin &gt;&gt; ix &gt;&gt; iy;    fors(i, n) //找正方形    {        fors(j, n)        {            fors(k, n)            {                fors(l, n)                {                    if (i == j or j == k or k == l or i == k or i == l or j == l) continue;  //判重                    if (cube1 and cube2 and other and zhijiao)                    {                        vis[i] = vis[j] = vis[k] = vis[l] = true; //标记点已被使用                        v.push_back(i), v.push_back(j), v.push_back(k), v.push_back(l);                        sort(v.begin(), v.end());  //暴力排序233                        done = 1;                        break;                    }                }                if (done)                    break;            }            if (done)                break;        }        if (done)            break;    }    if (!done) {cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return 0;}    done = 0;    fors(i, n) //找矩形    {        if (vis[i])  //如果当前点被使用了，跳过            continue;        fors(j, n)        {            if (vis[j])                continue;  //如果当前点被使用了，跳过            fors(k, n)            {                if (vis[k])                    continue;  //如果当前点被使用了，跳过                fors(l, n)                {                    if (vis[l])  //如果当前点被使用了，跳过                        continue;                    if (i == j or j == k or k == l or i == k or i == l or j ==      l) continue; //判重                    if (cube1 and other and zhijiao)                    {                        v1.push_back(i), v1.push_back(j), v1.push_back(k), v1.push_back(l);                        sort(v1.begin(), v1.end());  //暴力排序233                        done = 1;                        break;                    }                }                if (done)                    break;            }            if (done)                break;        }        if (done)            break;    }    if (!done) {cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return 0;}    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;  //输出答案    for (int q = 0; q &lt; 4; q++)        cout &lt;&lt; v[q] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    for (int q = 0; q &lt; 4; q++)        cout &lt;&lt; v1[q] &lt;&lt; &quot; &quot;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉筛</title>
      <link href="//articles/2019/10/%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
      <url>//articles/2019/10/%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<p>前置芝士：<a href="https://blog.liuzhe.site/articles/2019/10/%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%B0%8F%E8%AE%B0/" target="_blank" rel="noopener">Eratosthenes 筛法 （埃拉托斯特尼筛法）</a></p><h2 id="欧拉筛二三事"><a href="#欧拉筛二三事" class="headerlink" title="欧拉筛二三事"></a>欧拉筛二三事</h2><p>其实没什么辣，欧拉筛只是埃筛的一个小优化。</p><p>我们分析一下埃筛的代码：</p><pre><code class="lang-cpp">void sieve (){    composite[0] = true;  //0和1都是素数    composite[1] = true;    for (register int i = 2; i &lt;= n; i++)  //一直筛到n        for (register int j = i + i; j &lt;= n; j += i)  //如果一个数是素数,那么它的倍数也一定是素数            composite[j] = true;  //标记素数}</code></pre><p>注意这里：</p><pre><code class="lang-cpp">for (register int j = i + i; j &lt;= n; j += i)  //如果一个数是素数,那么它的倍数也一定是素数         composite[j] = true;  //标记素数</code></pre><p>这段代码在无脑的筛掉元素，为什么称它“无脑”呢？</p><p>对于同一个元素，埃筛可能会将它筛掉好多次。</p><p>埃氏筛时间复杂度：$O(n\log\log n)$</p><p>而接下来要介绍的<em>欧拉筛</em>的时间复杂度可以达到$O(n)$</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><blockquote><p>这里的欧拉筛全部以筛素数为例</p></blockquote><p>对于一个合数，欧拉筛会确保它只被筛一次。</p><p>我们必须明确一下几点：</p><ol><li>任何合数都可以表示为多个素数之积</li><li>每个合数必有一个最小素因子</li></ol><p>我们只需找出每个数的最小素因子即可。</p><p>先放一下代码，后面继续<del>江</del>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">void eulerSieve(){    composite[0] = true;    composite[1] = true;    for (register int i = 2; i &lt;= n; i++)    {        if (!composite[i]) //是素数的话，我们就把它加入列表中            ans[++num] = i;        for (register int j = 1; j &lt;= num &amp;&amp; i * ans[j] &lt;= n; j++) //i * ans[j] &lt;= n 判边界        {            composite[i * ans[j]] = true;  //（1）            if (i % ans[j] == 0)                break;        }    }}</code></pre><blockquote><p>字比较丑 QWQ~~~</p></blockquote><p>(1)：</p><p><img src="/10/欧拉筛/1.png" alt="1"></p><h3 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 筛法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷-P1469-找筷子</title>
      <link href="//articles/2019/10/%E6%B4%9B%E8%B0%B7-P1469-%E6%89%BE%E7%AD%B7%E5%AD%90/"/>
      <url>//articles/2019/10/%E6%B4%9B%E8%B0%B7-P1469-%E6%89%BE%E7%AD%B7%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P1469" target="_blank" rel="noopener">题目链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><strong>！！！内存限制4MB！！！</strong></p><p>经过一段时间的紧张筹备，电脑小组的“RP餐厅”终于开业了，这天，经理LXC接到了一个定餐大单，可把大家乐坏了！员工们齐心协力按要求准备好了套餐正准备派送时，突然碰到一个棘手的问题，筷子！CX小朋友找出了餐厅中所有的筷子，但遗憾的是这些筷子长短不一，而我们都知道筷子需要长度一样的才能组成一双，更麻烦的是CX找出来的这些筷子数量为奇数，但是巧合的是，这些筷子中只有一只筷子是落单的，其余都成双，善良的你，可以帮CX找出这只落单的筷子的长度吗？</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行读入一个数N，它代表CX找到的筷子的根数。</p><p>第二行是N个用空格隔开的数，代表筷子的长度。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行，落单的筷子的长度。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="Subtask-1-60-pts"><a href="#Subtask-1-60-pts" class="headerlink" title="Subtask #1 (60 pts)"></a>Subtask #1 (60 pts)</h4><p>开一个数组，对其进行排序，我们暴力扫一遍，判断哪个数出现了奇数次，哪个数就是答案。</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n,a[1000005];int main(){    ios::sync_with_stdio(false);    cin&gt;&gt;n;    for(register int i=1;i&lt;=n;i++)        cin&gt;&gt;a[i];            sort(a+1,a+n+1);    for(register int i=1;i&lt;=n;i++)    {        int cnt=1;        for(register int j=i+1;a[j]==a[j-1];j++)        {            cnt++;            i=j;;        }        if(cnt % 2 != 0)cout&lt;&lt;a[i];    }}</code></pre><h4 id="正解：位运算"><a href="#正解：位运算" class="headerlink" title="正解：位运算"></a>正解：位运算</h4><p>不知大家有没有听过<strong>异或</strong>运算。</p><p>异或运算的性质：</p><ul><li>如果两个数为1，就为0</li><li>如果两个数为0，就为0</li><li>如果两个数有一个为1，另一个为0，就为1</li></ul><p>其实就是二进制下的不进位加法。</p><p>我们还能发现：</p><ol><li><strong>两个相同的数进行异或运算后一定为0</strong></li><li><strong>任何数异或0都不变</strong></li></ol><p>所以，我们只需对所有的数异或一遍，最后剩的数即为答案。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, a, ans;int main(){    cin&gt;&gt;n;    for(register int i=1;i&lt;=n;i++)    {        cin &gt;&gt; a;        ans ^= a;    }    cout &lt;&lt; ans &lt;&lt; endl;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA1395-苗条的生成树-Slim-Span-题解</title>
      <link href="//articles/2019/10/UVA1395-%E8%8B%97%E6%9D%A1%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91-Slim-Span-%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/10/UVA1395-%E8%8B%97%E6%9D%A1%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91-Slim-Span-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>(PDF)[<a href="https://onlinejudge.org/external/13/p1395.pdf" target="_blank" rel="noopener">https://onlinejudge.org/external/13/p1395.pdf</a>]</p><h3 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h3><p>求一个生成树，使它最大边减最小边之差最小</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们暴力的生成多个生成树，然后取最小的最大边减最小边之差输出便可。</p><p>我们生成$m$次生成树，每进行第$i$次生成是我们要忽略$1 \sim i$的边。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int maxn  = 105;int fa[maxn], n, m, tot, min = 99999999;struct node{    int from, to, data;    bool operator &lt; (node &amp;b) const    {        return data &lt; b.data;    }} edge[10000];int find(int x){    if (fa[x] == x) return x;    return fa[x] = find(fa[x]);}inline int kelusikale(int x){    int num = 0, cnt = edge[x].data;    for (register int i = x; i &lt;= m; i++)    {        int xz = find(edge[i].from), yz = find(edge[i].to);        if (xz != yz)        {            ++num;            fa[xz] = yz;        }        if (num == n - 1)        {            return abs(cnt - edge[i].data);            break;        }    }    return -1;}int main(){    while (true)    {        min = 99999999;        memset(fa, 0, sizeof fa);        memset(edge, 0, sizeof edge);        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        if (n == 0 &amp;&amp; m == 0)            break;        if (m == 0)        {            printf(&quot;-1\n&quot;);            continue;        }        for (register int i = 1; i &lt;= m; i++)            scanf(&quot;%d%d%d&quot;, &amp;edge[i].from, &amp;edge[i].to, &amp;edge[i].data);        std::sort(edge + 1, edge + m + 1);        for (register int j = 1; j &lt;= m; j++)        {            for (register int i = 1; i &lt;= n; i++)                fa[i] = i;            int x = kelusikale(j);            if (x == -1 and j == 1)            {                min = -1;                break;            }            else if (x == -1) x = 99999999;            min = std::min(x, min);        }        printf(&quot;%d\n&quot;, min);    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2010乌龟棋</title>
      <link href="//articles/2019/10/NOIP2010%E4%B9%8C%E9%BE%9F%E6%A3%8B/"/>
      <url>//articles/2019/10/NOIP2010%E4%B9%8C%E9%BE%9F%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<p>DP题目</p><a id="more"></a><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>(luogu传送门)[<a href="https://www.luogu.org/problem/P1541" target="_blank" rel="noopener">https://www.luogu.org/problem/P1541</a>]</p><h4 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h4><p>小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>乌龟棋的棋盘是一行$N$N个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第$N$N格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。<br>乌龟棋中M$M$张爬行卡片，分成4种不同的类型（MM张卡片中不一定包含所有4$4$种类型的卡片，见样例），每种类型的卡片上分别标有$1,2,3,4$1,2,3,4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。<br>游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。<br>很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。<br>现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>每行中两个数之间用一个空格隔开。<br>第$1$行2$2$个正整数$N,M$，分别表示棋盘格子数和爬行卡片数。<br>第$2$行$N$个非负整数，$a_1,a_2,…,a_N$其中$a_i$表示棋盘第$i$个格子上的分数。<br>第$3$行$M$个整数，$b_1,b_2,…,b_M$，表示M张爬行卡片上的数字。<br>输入数据保证到达终点时刚好用光$M$张爬行卡片。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>$1$个整数，表示小明最多能得到的分数。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="假做法（记忆化搜索）"><a href="#假做法（记忆化搜索）" class="headerlink" title="假做法（记忆化搜索）"></a>假做法（记忆化搜索）</h4><p>我们可以设一个$f[i]$表示$i~n$的最大得分，我们还要维护一个$vis[]$，一旦这个卡片被搜索过，我们就不用这个卡片，转而用其他没有被用过的卡片更新状态。</p><h4 id="真做法（记忆化搜索）"><a href="#真做法（记忆化搜索）" class="headerlink" title="真做法（记忆化搜索）"></a>真做法（记忆化搜索）</h4><p>发现标记$vis$数组效率太低，我们可以多设三维状态优化这个问题。</p><p>我们设$f[a][b][c][d]$为使用了$a$次一号卡片，$b$次二号卡片，$c$次三号卡片，$d$次四号卡片，那么我们乌龟移动的位置可以表示为：</p><script type="math/tex; mode=display">1 + a \times 1 + b \times 2 + c \times 3 + d \times 4</script><blockquote><p>我们从1开始走，所以要加上一个1</p></blockquote><p>一个显然成立的方程式：</p><script type="math/tex; mode=display">\left\{\begin{array}{rcl}\max(f[a][b][c][d], a[pos] + dp(a + 1, b, c, d))\\\max(f[a][b][c][d], a[pos] + dp(a, b + 1, c, d))\\\max(f[a][b][c][d], a[pos] + dp(a, b, c + 1, d))\\\max(f[a][b][c][d], a[pos] + dp(a, b, c, d + 1))\\\end{array} \right.</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;cstdio&gt;#define pos a + b * 2 + c * 3 + d * 4 + 1#define maxn 350#define max(a, b) a &gt; b ? a : b#define fors(a, b, c, d) for (register int a = b; a &lt;= c; a += d)int n, m, map[maxn], ca[5], f[44][44][44][44];int dfs(const int a, const int b, const int c, const int d) //const为防止写代码时犯zz错误{    if (f[a][b][c][d])        return f[a][b][c][d];    if (a == ca[1] and b == ca[2] and c == ca[3] and d == ca[4])        return map[n];    if (a &lt; ca[1])        f[a][b][c][d] = max(f[a][b][c][d], map[pos] + dfs(a + 1, b, c, d));    if (b &lt; ca[2])        f[a][b][c][d] = max(f[a][b][c][d], map[pos] + dfs(a, b + 1, c, d));    if (c &lt; ca[3])        f[a][b][c][d] = max(f[a][b][c][d], map[pos] + dfs(a, b, c + 1, d));    if (d &lt; ca[4])        f[a][b][c][d] = max(f[a][b][c][d], map[pos] + dfs(a, b, c, d + 1));    return f[a][b][c][d];}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    fors(i, 1, n, 1)    scanf(&quot;%d&quot;, &amp;map[i]);    fors(i, 1, m, 1)    {        int x;        scanf(&quot;%d&quot;, &amp;x);        ca[x]++;    }    printf(&quot;%d\n&quot;, dfs(0, 0, 0, 0));    return 0;}</code></pre><h3 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu-P1613-跑路</title>
      <link href="//articles/2019/10/Luogu-P1613-%E8%B7%91%E8%B7%AF/"/>
      <url>//articles/2019/10/Luogu-P1613-%E8%B7%91%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>倍增+floyed</p><a id="more"></a><p><a href="https://www.luogu.org/problem/P1613" target="_blank" rel="noopener">题目链接</a></p><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小A的工作不仅繁琐，更有苛刻的规定，要求小A每天早上在6：00之前到达公司，否则这个月工资清零。可是小A偏偏又有赖床的坏毛病。于是为了保住自己的工资，小A买了一个十分牛B的空间跑路器，每秒钟可以跑2^k千米（k是任意自然数）。当然，这个机器是用longint存的，所以总跑路长度不能超过maxlongint千米。小A的家到公司的路可以看做一个有向图，小A家为点1，公司为点n，每条边长度均为一千米。小A想每天能醒地尽量晚，所以让你帮他算算，他最少需要几秒才能到公司。数据保证1到n至少有一条路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数n，m，表示点的个数和边的个数。<br>接下来m行每行两个数字u，v，表示一条u到v的边。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行一个数字，表示到公司的最少秒数。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一开始想的预处理出2^k的数的数组，之后跑一边floyed，判断哪些路径是2^k方，将其替换，最后跑一边Dijkstra。</p><blockquote><p><del>做法极其zz</del></p></blockquote><p>后因懒得写，于是去康了一眼罪恶的题解，emmmm，原来一遍倍增+floyed便可。</p><p>我们开一个布尔数组$f[i][j][k]$，表示$i \to j$的路径为是否$2^k$。</p><p>根据初中学的知识，我们可得：</p><script type="math/tex; mode=display">2^{k-1} + 2^{k-1} = 2^k</script><p>所以说我们只需要知道$f[a][b][k-1],f[b][c][k-1]$是否唯一便可以知道是否可以在$a \to b$的路径上使用空间跑路器啦。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include &lt;cstring&gt;#include &lt;string&gt;#define fors(a,b,c,d) for(register long long a=b;a&lt;=c;a+=d)#define maxn 55using namespace std;long long n, map[maxn][maxn], x, y, m;bool a[maxn][maxn][64];void floyd(){    fors (l, 1, 64, 1) //多枚举一层    fors (k, 1, n, 1)    fors (i, 1, n, 1)    fors (j, 1, n, 1)    if (a[i][k][l - 1] and a[k][j][l - 1])    {        a[i][j][l] = 1; //如果a[i][k][l - 1]，a[k][j][l - 1]可以，那么我们便可以在i -&gt; j 上使用跑路器        map[i][j] = 1;    }    else map[i][j] = min(map[i][k] + map[k][j], map[i][j]); //否则更新}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; m;    memset(map, 0x3f3f, sizeof map);    fors(i, 1, m, 1)    {        cin &gt;&gt; x &gt;&gt; y;        map[x][y] = 1;        a[x][y][0] = 1; //x,y能在2^0内到达。    }    floyd();    cout &lt;&lt; map[1][n] &lt;&lt; endl;    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组求逆序对数</title>
      <link href="//articles/2019/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/"/>
      <url>//articles/2019/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>前置芝士：树状数组</strong></p><a id="more"></a><h2 id="树状数组求逆序对数"><a href="#树状数组求逆序对数" class="headerlink" title="树状数组求逆序对数"></a>树状数组求逆序对数</h2><p>逆序数的定义：对于一个数列$a_n$所有满足$a_i &gt; a_j$ 且 $i &lt; j$的二元组的个数称为逆序数。</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>假如我们有一列数:</p><p>对于一个数$i$，我们把第$i$位++，之后在统计1 ~ i的区间和，这个区间和便是$i$的顺序对，用$i$再减去这个数即为逆序对。</p><p>为什么这样能行得通呢，我们回想一下逆序对的定义，$a_i &gt; a_j$ 且 $i &lt; j$的二元组，我们在按原数组顺序插入如的时候，其实已经保证了$i &lt; j$，我们插入又恰恰满足了，$a_i &gt; a_j$。</p><p>例如我们有以下元素：</p><script type="math/tex; mode=display">2,1,4,7</script><p>我们从前往后插入进树状数组内，</p><p>先插入$2$，第$2$个位置的数据=1。</p><p>查询1~2的区间和，为$1$，所以他的顺序对数为$1$，逆序对数为$1-1=0$。</p><div class="table-container"><table><thead><tr><th>位置</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>树状数组</td><td></td><td>1</td></tr><tr><td>数据</td><td></td><td>1</td></tr></tbody></table></div><p>再插入$1$，把第$1$个位置的数据=1。</p><p>查询1~1的区间和，为$1$，所以他的顺序对数为$1$，逆序对数为$2-1=1$。</p><div class="table-container"><table><thead><tr><th>位置</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>树状数组</td><td>1</td><td>1</td></tr><tr><td>数据</td><td>1</td><td>2</td></tr></tbody></table></div><p>再插入$4$，把第$4$个位置的数据=1。</p><p>查询1~1的区间和，为$4$，所以他的顺序对数为$3$，逆序对数为$3-3=0$。</p><div class="table-container"><table><thead><tr><th>位置</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>树状数组</td><td>1</td><td>1</td><td></td><td>1</td></tr><tr><td>数据</td><td>1</td><td>2</td><td></td><td>1</td></tr></tbody></table></div><p>再插入$7$，把第$7$个位置的数据=1。</p><p>查询1~1的区间和，为$4$，所以他的顺序对数为$4$，逆序对数为$4-4=0$。</p><div class="table-container"><table><thead><tr><th>位置</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>树状数组</td><td>1</td><td>1</td><td></td><td>1</td><td></td><td></td><td>1</td></tr><tr><td>数据</td><td>1</td><td>2</td><td></td><td>1</td><td></td><td></td><td>1</td></tr></tbody></table></div><h2 id="代码实现-以洛谷P1908-逆序对-为例"><a href="#代码实现-以洛谷P1908-逆序对-为例" class="headerlink" title="代码实现 以洛谷P1908 逆序对 为例"></a>代码实现 以洛谷P1908 逆序对 为例</h2><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;#define endl &#39;\n&#39;#define maxn 500005struct node{    long long data, rk;    bool operator&lt; (const node &amp;b)const  //供排序用    {        if (data == b.data)            return rk &lt; b.rk;        return data &lt; b.data;    }} c[maxn];long long n, a[maxn], _rank[maxn];inline long long lowbit(long long x){    return x &amp; (-x);}inline void add(long long pos, long long x){    for (register long long i = pos; i &lt;= n; i += lowbit(i))        a[i] += x;}inline long long sum(long long pos){    long long sum = 0;    for (register long long i = pos; i &gt;= 1; i -= lowbit(i))        sum += a[i];    return sum;}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n;    for (register long long i = 1; i &lt;= n; i++) //输入数据    {        cin &gt;&gt; c[i].data;          c[i].rk = i; //c[i]在数组中的序号    }    sort(c + 1, c + n + 1); //排序（离散化）    for (register long long i = 1; i &lt;= n; i++)        _rank[c[i].rk] = i; //求相对大小    /*    //  1 2 10000    //  1 2 3    //上面两个序列在本题是等效的，因为无论第三项是3还是10000，它都大于第一项和第二项    我们的目标是把原先大的数缩小    因为排完序的序列和原序列长度相同    以1为例：    我们令原先c[1].rk(即最小的数位置)等与1。    接着我们令原先c[2].rk(即次小的数位置)等与2。    这便起到缩小数据的作用    */    long long ans = 0;    for (register long long i = 1; i &lt;= n; i++)    {        add(_rank[i], 1);        ans += i - sum(_rank[i]);  //求逆序对    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 区间 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅行题解</title>
      <link href="//articles/2019/10/%E6%97%85%E8%A1%8C%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/10/%E6%97%85%E8%A1%8C%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vijos.org/p/1615" target="_blank" rel="noopener">题目链接</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>今天是个神圣的日子，因为LHX教主要进行一段长途旅行。但是教主毕竟是教主，他喜欢走自己的路，让别人目瞪口呆。为什么呢，因为这条路线高低不平，而且是相当的严重。</p><p>但是教主有自己的办法，他会魔法。</p><p>这段路可以用一个长度为N的序列A[I]来表示，A[I]表示了第I这段路的高度。毕竟教主即使会使用魔法他还是个人，教主如果想穿越这条路线，他必须从第1段路开始走，走到第N段，从第I段走到第I+1段路需要消耗|A[I+1]-A[I]|点体力。为了节省体力，教主使出了他神奇的魔法。教主的魔法可以将一段路高度变高或者变低，但是使用魔法也需要体力，改变一段路H的高度就需要消耗H的体力。即若教主把第I段路高度从A[I]变成了K，那么他需要消耗|A[I]-K|点体力。</p><p>接着，LHX教主想规划下如何调整路段高度后穿越，使得总体力消耗最小。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第1行为一个<strong>正整数</strong>N，表示了这条路线的长度。</p><p>第2行有N个<strong>正整数</strong>，相邻两个正整数用空格隔开，描述了A[I]这个序列。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅包括一个<strong>非负整数</strong>，为最小的总体力消耗。</p><p><strong>注意：答案可能超过2^31-1，请使用int64或者long long类型保存答案。</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此题一看就是贪心（</p><p>考场上想这题时，觉得是贪心，然后憨憨的认为把所有的路的高度变成一个定值肯定是最优的。</p><p>于是乎，之后便落入此思维之坑，一落不复返。</p><p><del>关键是对拍暴力也写的是推平</del></p><p>后来被Herself32间接喷为SB做法。</p><blockquote><p>Herself32：liuzhe，你太屑了。<br>liuzhe：被dalao喷了/kk，/kk，/kk。</p></blockquote><p>终于在一筹莫展的时候得到了shq的指导。于是<del>我不由自主地膜拜起了真神shq</del>，写出来了~~~。</p><p><del>膜拜上述两位dalao</del></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们考虑画出道路的图片来<del>（Surface爽翻天）</del></p><p><img src="/10/旅行题解/1.png" alt="1"></p><p><del>一条艰难曲折的道路</del></p><p>我们发现这条道路有许多深坑，我们如果不填平的话，就会有一部分是多计算的（黄色部分）</p><p><img src="/10/旅行题解/2.png" alt="2"></p><p>于是我们填平它。</p><p><img src="/10/旅行题解/3.png" alt="3"></p><p>对于凸出来的小土包，我们若不推平它，也会有一部分是多计算的（红色部分）</p><p><img src="/10/旅行题解/4.png" alt="4"></p><p><del>如果我们的推土机继续前进，这个螳臂当车的土包难道能阻挡得了吗？</del></p><p>推平代码如下</p><pre><code class="lang-cpp">    for (register int i = 2; i &lt;= n; i++)    {        if (a[i] &lt; a[i + 1] and a[i] &lt; a[i - 1]) //是个坑        {            ans += abs(a[i] - min(a[i - 1], a[i + 1]));            a[i] = min(a[i - 1], a[i + 1]);        }        if (a[i] &gt; a[i + 1] and a[i] &gt; a[i - 1]) //是个小土包        {            ans += abs(a[i] - max(a[i - 1], a[i + 1]));            a[i] = max(a[i - 1], a[i + 1]);        }    }</code></pre><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>应该很好理解，不打注释了</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define maxn 100005using namespace std;int n;long long a[maxn], ans;int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n;    for (register int i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i];    for (register int i = 2; i &lt;= n; i++)    {        if (a[i] &lt; a[i + 1] and a[i] &lt; a[i - 1])        {            ans += abs(a[i] - min(a[i - 1], a[i + 1]));            a[i] = min(a[i - 1], a[i + 1]);        }        if (a[i] &gt; a[i + 1] and a[i] &gt; a[i - 1])        {            ans += abs(a[i] - max(a[i - 1], a[i + 1]));            a[i] = max(a[i - 1], a[i + 1]);        }    }    for (register int i = 2; i &lt;= n; i++)        ans += abs(a[i] - a[i - 1]);    cout &lt;&lt; ans;    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【杂记】中山纪念中学中DAY1的记录</title>
      <link href="//articles/2019/10/%E4%B8%AD%E5%B1%B1%E7%BA%AA%E5%BF%B5%E4%B8%AD%E5%AD%A6%E4%B8%ADDAY1%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
      <url>//articles/2019/10/%E4%B8%AD%E5%B1%B1%E7%BA%AA%E5%BF%B5%E4%B8%AD%E5%AD%A6%E4%B8%ADDAY1%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>额，这里的人都好强啊</p><p>先放一下DAY1的题目吧</p><h2 id="T1珂学家"><a href="#T1珂学家" class="headerlink" title="T1珂学家"></a>T1珂学家</h2><p><del>好吧，丧心病狂的我看了之后还以为是珂朵莉树</del></p><p><a href="https://gmoj.net/senior/#main/show/6384" target="_blank" rel="noopener">链接</a></p><p>正解1：<br>枚举 ,考虑他们的贡献。<br>可以发现是可以拆成两个区间加等差数列的形式。<br>那么差分两次，就是单点加。<br>最后在前缀和变回去即可。</p><p>正解2：NTT（不会NTT的我哭出声来）</p><p><del>所以说他们的NTT是用来打暴力的？？？</del></p><p>我在考场上（40分）：</p><ol><li>写了一个极为憨憨的枚举。</li><li>后来发现可以用两个指针来维护两个试剂的$l$和$r$的范围。</li><li>发现范围可以$O(1)$求</li><li><del>卡常</del></li></ol><p>总结：emmmm，在不会的时候，先把暴力打上吧，山重水复疑无路，柳暗花明又一村，不知什么时候您可能就会突发奇想，把暴力优化了一维呢。</p><h2 id="T2-and-T3"><a href="#T2-and-T3" class="headerlink" title="T2 and T3"></a>T2 and T3</h2><p>概率期望，自闭了</p><p>不过反复观察，便可发现，数据范围中有$5\%$的数据是白送的，于是又赚了10pts，qwq。</p><p>总结：分析题目很重要。</p><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2><blockquote><p>Don’t depend too much on anyone in this world, because even your shadow leaves you when you’re in darkness.</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CF1179A-Valeriy-and-Deque题解</title>
      <link href="//articles/2019/10/CF1179A-Valeriy-and-Deque%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/10/CF1179A-Valeriy-and-Deque%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>找规律题目</p><a id="more"></a><p><a href="https://www.luogu.org/problem/CF1179A" target="_blank" rel="noopener">洛谷地址</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Recently, on the course of algorithms and data structures, Valeriy learned how to use a deque. He built a deque filled with n n elements. The $i$-th element is $a_i​ ( i = 1, 2, \ldots, n )$. He gradually takes the first two leftmost elements from the deque (let’s call them $A$ and $B$ , respectively), and then does the following: if $A &gt; B$ , he writes $A$ to the beginning and writes $B$ to the end of the deque, otherwise, he writes to the beginning $B$ , and $A$ writes to the end of the deque. We call this sequence of actions an operation.</p><p>For example, if deque was $[2, 3, 4, 5, 1]$ , on the operation he will write $B=3$ to the beginning and $A=2$ to the end, so he will get $[3, 4, 5, 1, 2]$ .</p><p>The teacher of the course, seeing Valeriy, who was passionate about his work, approached him and gave him $q$ queries. Each query consists of the singular number $m_j (j = 1, 2, \ldots, q)$ . It is required for each query to answer which two elements he will pull out on the $m_j$ -th operation.</p><p>Note that the queries are independent and for each query the numbers $A$ and $B$ should be printed in the order in which they will be pulled out of the deque.</p><p>Deque is a data structure representing a list of elements where insertion of new elements or deletion of existing elements can be made from both sides.</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题其实是一个毒瘤找规律题目,暴力会TLE,<del>不开long long会见祖宗</del></p><p>对于这样一组数据:</p><p>$1, 2, 3, 4, 5$</p><p>继续操作下去之后,</p><p>它变成了这样:</p><p>$23451$</p><p>$34512$</p><p>$45123$</p><p>$51234$</p><p>$52341$</p><p>$53412$</p><p>$54123$</p><p>$51234$</p><p>$52341$</p><p>有没有发现出现循环节了???</p><p>$51234$</p><p>$52341$</p><p>$53412$</p><p>$54123$</p><p>这就是重复的部分</p><p>我们继续尝试<del>亿</del>组数据,可以发现一个显然的条件:</p><p><strong>最大的数总是出现循环节的开头,且循环节的长度为$n-1$</strong></p><p>我们就可以利用这个来做题了</p><p>我们先找出它的循环节,对于他询问的不在循环节内的,我们暴力跑一遍就可以,在循环节内的,我们对询问的步数取个模,之后在循环节中查找便可.</p><p><strong>详见注释</strong></p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><pre><code class="lang-cpp">#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define endl &#39;\n&#39;#define LL long longstd::vector&lt;LL&gt; ans;std::deque&lt;LL&gt; q;LL n, QAQ, maxx, m, pos;LL vis[400005][2], cnt; //记录非循环节的队列信息inline LL max (LL a, LL b){    return a &gt; b ? a : b;}int main (){    std::ios::sync_with_stdio (false); //读入小优化    std::cin.tie (0);    std::cout.tie (0);    std::cin &gt;&gt; n &gt;&gt; QAQ;    for (register LL i = 0, x; i &lt; n; i++)    {        std::cin &gt;&gt; x;        maxx = max (maxx, x);  //找到最大的元素        q.push_back (x);  //加入双端队列    }    for (register LL i = 1, a, b, done = 1; true; i++)    {        a = q.front (), q.pop_front ();  //取出元素        b = q.front (), q.pop_front ();        vis[++cnt][0] = a;  //记录        vis[cnt][1] = b;        if (a == maxx)   //出现循环节        {            if (done)   //我们记录循环节首次出现的操作步数            {                pos = i;                done = 0;                ans.push_back (b);  //加入存储循环节的数组            }            else if (ans[0] == b and i - pos &gt;= n - 1) //当它的元素与之前重复且以循环n-1遍            {                m = i - pos; //记录循环节的长度                break;            }            else                ans.push_back (b);          }        if (a &gt; b)        {            q.push_front (a);            q.push_back (b);        }        else        {            q.push_back (a);            q.push_front (b);        }    }    for (register LL i = 1, cmd; i &lt;= QAQ; i++)  //输出答案    {        std::cin &gt;&gt; cmd;        if (cmd &lt;= pos) //在循环节内            std::cout &lt;&lt; vis[cmd][0] &lt;&lt; &quot; &quot; &lt;&lt; vis[cmd][1] &lt;&lt; endl;        else //不在循环节内            std::cout &lt;&lt; maxx &lt;&lt; &quot; &quot; &lt;&lt; ans[(cmd - pos) % m] &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 乱搞 </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018货币系统题解</title>
      <link href="//articles/2019/10/NOIP2018%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/10/NOIP2018%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>NOIP2018 TG DAY1 T2</p><blockquote><p>筛法筛货币</p></blockquote><a id="more"></a><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://www.luogu.org/problem/P5020" target="_blank" rel="noopener">原题地址</a></p><p>在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。</p><p>在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3, a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。</p><p>两个货币系统 (n,a)和 (m,b) 是等价的，当且仅当对于任意非负整数 xx，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。</p><p>现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你n个货币,问你有最多有多少个货币可以被其他面额的货币表示出来,你需要精简这个货币系统.</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们考虑用筛法做这题.</p><p>对于每一个货币.我们把他能表示出来的面额筛掉,如果我们筛掉的面额是货币的话,就更新答案,最后用总数$n-answer$就是我们要的答案了.</p><p><strong>代码中有详细注释</strong></p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><pre><code class="lang-cpp">#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define endl &#39;\n&#39;#define maxn 102using namespace std;int t, n;int m[25005];int main (){    ios::sync_with_stdio (false);    cin.tie (0);    cout.tie (0);    cin &gt;&gt; t;    while (t--)    {        memset (m, 0, sizeof m);  //多测要清空        int a[maxn], ans = 0;        cin &gt;&gt; n;        for (register int i = 1; i &lt;= n; i++)        {            cin &gt;&gt; a[i];            m[a[i]] = 2;  //2表示这个货币是已有的,1表示这个面额能被其他货币组合出来        }        sort (a + 1, a + n + 1);  //排一遍序,我们要从最小的开始筛        for (register int i = 1; i &lt;= a[n]; i++)            if (m[i]) //如果他能被组合或已有                for (register int j = 1; j &lt;= n; j++) //把所有能表示出的货币筛掉                    if (i + a[j] &lt;= a[n]) //边界                    {                        if (m[i + a[j]] == 2) ans++;  //如果可以替换原有的就更新答案                        m[i + a[j]] = 1;                    }        cout &lt;&lt; n - ans &lt;&lt; endl; //输出    }    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 筛法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>埃氏筛小记</title>
      <link href="//articles/2019/10/%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%B0%8F%E8%AE%B0/"/>
      <url>//articles/2019/10/%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>好久没写线性筛了,感觉自己要忘了,写篇小记以记之.</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>筛法是数论中的一个重要的思想,这篇文章以埃氏筛筛素数介绍.</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>首先我们需要知道什么是素数和合数</p><p><del>我上高一才刚分清</del></p><ul><li>合数: 可以被$1$和它自己及其他数整除的.</li><li>素数(质数): 只能被它自己和$1$整除的.</li></ul><p>对于一个数(除了$1$,$0$),他大于$1$的整数倍一定是一个合数.</p><p>这个命题显然成立.</p><p>例如$2$ </p><p>他大于$1$的整数倍$4$,$6$,$8$,$10$等,这些数都是合数.</p><p>我们的算法就是把非$0$和$1$的数字乘上多倍后,打上标记,标记这些是合数,最后没有标记的就是素数了.</p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><pre><code class="lang-cpp">void sieve (){    composite[0] = true;  //0和1都是合数    composite[1] = true;    for (register int i = 2; i &lt;= n; i++)  //一直筛到n        for (register int j = i + i; j &lt;= n; j += i)  //如果一个数是合数,那么它的倍数也一定是合数            composite[j] = true;  //标记合数}</code></pre><h2 id="食用方法（以洛谷P3383-【模板】线性筛素数）为例"><a href="#食用方法（以洛谷P3383-【模板】线性筛素数）为例" class="headerlink" title="食用方法（以洛谷P3383 【模板】线性筛素数）为例"></a>食用方法（以<a href="https://www.luogu.org/problem/P3383" target="_blank" rel="noopener">洛谷P3383 【模板】线性筛素数</a>）为例</h2><pre><code class="lang-cpp">#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define maxn 10000005using namespace std;bool composite[maxn] = {};int num = 0, n, m;void sieve (){    composite[0] = true;  //0和1都是合数    composite[1] = true;    for (register int i = 2; i &lt;= n; i++)  //一直筛到n        for (register int j = i + i; j &lt;= n; j += i)  //如果一个数是合数,那么它的倍数也一定是合数            composite[j] = true;  //标记合数}int main (){    ios::sync_with_stdio (false); //关同步    cin.tie (0);    cout.tie (0);    cin &gt;&gt; n &gt;&gt; m;    sieve ();  //筛一遍    int k;    while (m--)    {        cin &gt;&gt; k;        if (composite[k])            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;        else            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 筛法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针-CF660C题解</title>
      <link href="//articles/2019/10/%E5%8F%8C%E6%8C%87%E9%92%88-CF660C%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/10/%E5%8F%8C%E6%8C%87%E9%92%88-CF660C%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>双指针题目</p><blockquote><p>感谢谢Herself32 dalao 的讲解</p></blockquote><p><a href="https://www.luogu.org/problem/CF660C" target="_blank" rel="noopener">luogu题目地址</a></p><p><a href="https://codeforces.com/problemset/problem/660/C" target="_blank" rel="noopener">codeforces题目地址</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><center>C. Hard Processtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard output</center><p>You are given an array a with n elements. Each element of a is either $0$ or $1$.</p><p>Let’s denote the length of the longest subsegment of consecutive elements in $a$, consisting of only numbers one, as $f(a)$. You can change no more than $k$ zeroes to ones to maximize $f(a)$.</p><p><strong>Input</strong><br>The first line contains two integers $n$ and $k (1 \leq n \leq 3·10^5, 0 \leq k \leq n)$ — the number of elements in $a$ and the parameter $k$.</p><p>The second line contains $n$ integers $a_i (0 \leq a_i \leq 1)$ — the elements of $a$.</p><p><strong>Output</strong><br>On the first line print a non-negative integer $z$ — the maximal value of $f(a)$ after no more than k changes of zeroes to ones.</p><p>On the second line print $n$ integers $a_j$ — the elements of the array $a$ after the changes.</p><p>If there are multiple answers, you can print any one of them.</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="假做法1"><a href="#假做法1" class="headerlink" title="假做法1"></a>假做法1</h2><p>我们发现我们把$k$次机会全部使用完是最佳决策。</p><p>于是我们只需暴力枚举一个左端点$l$和一个右端点$r$，统计他们中间的$0$的个数。<br>复杂度$O(n^3)$</p><h2 id="假做法2"><a href="#假做法2" class="headerlink" title="假做法2"></a>假做法2</h2><p>前缀和优化一下。</p><p>时间复杂度$O(n^2)$。</p><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>我们用双指针解这题，我们首先定义一个$l$和$r$，和假做法1一样，我们需要统计$0$的个数，我们能够更新答案的时候，当且仅当$0$的个数$\leq k$，如果条件成立，我们把$r++$之后再次进行判断，否则缩小区间，令$l++$便可。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>卡了常，代码可读性会有些差。</p><pre><code class="lang-cpp">#include &lt;cstdio&gt;#define maxn 300005int a[maxn];int n, k;int main (){    register int l = 1, r = 1, cnt = 0, qwq, ans = 0, L, R;      //小变量放到寄存器里    scanf (&quot;%d%d&quot;, &amp;n, &amp;k);    for (register int i = 1; i &lt;= n; ++i)    {        getchar ();              //因为是 0 1， 所以快读常数比getchar大 ，不用写快读啦        a[i] = getchar () - &#39;0&#39;;    }    while (r &lt;= n)    {        cnt += !a[r];      //统计0的个数        if (cnt &gt; k)        {            cnt -= !a[l];            ++l;        }        qwq = r - l + 1;   //临时变量，减少计算次数        if (qwq &gt; ans)    //杜绝MAX 减少赋值次数        {            ans = qwq;            L = l;            R = r;        }        ++r;    }    printf (&quot;%d\n&quot;, ans);    for (register int i = L; i &lt;= R; i++) a[i] = true;    for (register int i = 1; i &lt;= n; i++)    {        putchar (a[i] + &#39;0&#39;);        putchar (&#39; &#39;);    }    return 0;}</code></pre><p><del>于是成功在2019.10.21卡到luogu最优解第一页</del></p><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P2613有理数取余题解</title>
      <link href="//articles/2019/10/%E6%B4%9B%E8%B0%B7P2613%E6%9C%89%E7%90%86%E6%95%B0%E5%8F%96%E4%BD%99%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/10/%E6%B4%9B%E8%B0%B7P2613%E6%9C%89%E7%90%86%E6%95%B0%E5%8F%96%E4%BD%99%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>逆元</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个有理数$c=\frac{a}{b}$ ，求$c \bmod 19260817$的值。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>一共两行。</p><p>第一行，一个整数$a$。<br>第二行，一个整数$b$。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一个整数，代表求余后的结果。如果无解，输出<code>Angry!</code></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于$c=\frac{a}{b}$求$c \bmod 19260817$，相当于求$\frac{a}{b} \bmod 19260817$也就是$a\times b^{-1} \bmod 19260817$</p><p>之后我们求个逆元就行啦。</p><p>$exgcd$求逆元证明（倒推）：</p><script type="math/tex; mode=display">ax + by = 1</script><script type="math/tex; mode=display">ax \bmod b + by \bmod b = 1 \bmod b</script><script type="math/tex; mode=display">ax \bmod b + 0 = 1 \bmod b</script><script type="math/tex; mode=display">ax \bmod b=1 \bmod b</script><script type="math/tex; mode=display">ax\equiv 1 \pmod b</script><h1 id="Code-不要打我，懒得高精"><a href="#Code-不要打我，懒得高精" class="headerlink" title="Code (不要打我，懒得高精)"></a>Code (不要打我，懒得高精)</h1><pre><code class="lang-python">#!/usr/bin/python3# -*- coding: UTF-8 -*-def exgcd(a, b):      # 求exgcd    if(b == 0):        x = 1        y = 0        return x, y    x, y = exgcd(b, a % b)    tx = x    x = y    y = tx - (a // b) * y    return x, ymod = 19260817a = int(input())b = int(input())if (b == 0):    # 0不能做除数    print(&quot;Angry!&quot;)else:    x, y = exgcd(b, mod)    x = (x % mod + mod) % mod    print(a*x % mod)</code></pre><h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> exgcd </tag>
            
            <tag> 逆元 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1144最短路计数</title>
      <link href="//articles/2019/10/%E6%B4%9B%E8%B0%B7P1144%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%A1%E6%95%B0/"/>
      <url>//articles/2019/10/%E6%B4%9B%E8%B0%B7P1144%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P1144" target="_blank" rel="noopener">题目：</a><a href="https://www.luogu.org/problem/P1144" target="_blank" rel="noopener">https://www.luogu.org/problem/P1144</a></p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个$N$个顶点$M$条边的无向无权图，顶点编号为$1-N$。问从顶点$1$开始，到其他每个点的最短路有几条。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行包含22个正整数$N,M$，为图的顶点数与边数。</p><p>接下来$M$行，每行22个正整数$x,y$，表示有一条顶点$x$连向顶点$y$的边，请注意可能有自环与重边。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>共$N$行，每行一个非负整数，第$i$行输出从顶点$1$到顶点$i$有多少条不同的最短路，由于答案有可能会很大，你只需要输出 ans mod 100003 后的结果即可。如果无法到达顶点$i$则输出$0$。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们开一个$ans$数组，记录$１$号到点到当前节点的路径个数。</p><p>所以，我们只需多加下面的代码即可：</p><pre><code class="lang-cpp">if (dis[v] == dis[u] + 1)    ans[v] = (ans[v] + ans[u]) % 100003;</code></pre><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="lang-cpp">#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define maxn 2000002#define endl &#39;\n&#39;#define pairs pair&lt;int, int&gt;#define mod % 100003using namespace std;struct node{    int to, next;} edge[maxn &lt;&lt; 1];int n, m;int head[maxn], num;int vis[maxn], dis[maxn];long long ans[maxn];inline void add_edge (int from, int to){    edge[++num].next = head[from];    edge[num].to = to;    head[from] = num;}inline void dijkstra (int x){    ans[x] = 1;    for (register int i = 1; i &lt;= n; i++) dis[i] = 2147483647;    priority_queue&lt;pairs&gt; q;    dis[x] = 0;    q.push (make_pair (0, 1));    while (!q.empty ())    {        int u = q.top ().second;        q.pop ();        if (vis[u]) continue;        vis[u] = 1;        for (register int i = head[u]; i; i = edge[i].next)        {            int v = edge[i].to;            if (dis[v] &gt; dis[u] + 1)            {                dis[v] = dis[u] + 1;                q.push (make_pair (-dis[v], v));            }            if (dis[v] == dis[u] + 1) ans[v] = (ans[v] + ans[u])mod;        }    }}int main (){    ios::sync_with_stdio (false);    cin.tie (0);    cout.tie (0);    cin &gt;&gt; n &gt;&gt; m;    for (register int i = 1; i &lt;= m; i++)    {        int x, y;        cin &gt;&gt; x &gt;&gt; y;        add_edge (x, y);        add_edge (y, x);    }    dijkstra (1);    for (register int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分层图最短路小记</title>
      <link href="//articles/2019/10/%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%B0%8F%E8%AE%B0/"/>
      <url>//articles/2019/10/%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>分层图最短路，顾名思义，是一种在分层图下求最短路的方法。</p><p>一般模型是：</p><p>在图上，有k次机会可以直接通过一条边，问起点与终点之间的最短路径。</p><a id="more"></a> <h1 id="例题-JLOI2011-飞行路线-（洛谷P4568"><a href="#例题-JLOI2011-飞行路线-（洛谷P4568" class="headerlink" title="例题 JLOI2011 飞行路线 （洛谷P4568 )"></a>例题 JLOI2011 飞行路线 （洛谷P4568 )</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在nn个城市设有业务，设这些城市分别标记为00到n-1n−1，一共有mm种航线，每种航线连接两个城市，并且航线有一定的价格。</p><p>Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多kk种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>数据的第一行有三个整数，n,m,kn,m,k，分别表示城市数，航线数和免费乘坐次数。<br>第二行有两个整数，s,ts,t，分别表示他们出行的起点城市编号和终点城市编号。<br>接下来有m行，每行三个整数，a,b,ca,b,c，表示存在一种航线，能从城市aa到达城市bb，或从城市bb到达城市aa，价格为cc。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一行，包含一个整数，为最少花费。</p><h1 id="解法一（DP）"><a href="#解法一（DP）" class="headerlink" title="解法一（DP）"></a><strong>解法一</strong>（DP）</h1><p>还记得最短路么？</p><p>最短路的状态是这么转移的：</p><script type="math/tex; mode=display">dis_i=\min(dis_i,dis_{from}+w)</script><p>而在分层图最短路中，我们可以开一个二维的$dis_i,_j$，表示到起始节点到$i$号节点，已使用$j$次机会的代价。</p><p>于是我们便得到了这么一个状态转移方程：</p><script type="math/tex; mode=display">dis _i,_j=\min(dis_{from,j−1},dis_{from,j}+w)</script><p>代码大致和dijkstra差不多，我就只贴dijkstra的代码了。</p><p>代码大致如下：</p><pre><code class="lang-cpp">struct Heap{    int u, v, now;    bool operator&lt;(const Heap &amp;b) const    {        return v &gt; b.v;    }};inline void dijkstra(int x){    dis[x][0] = 0;    priority_queue&lt;Heap&gt; q;    q.push((Heap){x, 0, 0});    while (!q.empty())    {        int u = q.top().u;        int now = q.top().now;        q.pop();        if (vis[u][now]) //vis也要开二维            continue;        vis[u][now] = true;        for (register int i = head[u]; i; i = edge[i].next)        {            int v = edge[i].to;            if (!vis[v][now + 1] &amp;&amp; now &lt; k &amp;&amp; dis[v][now + 1] &gt; dis[u][now]) //使用免费机会            {                dis[v][now + 1] = dis[u][now];                q.push((Heap){v, dis[v][now + 1], now + 1});            }            if (!vis[v][now] &amp;&amp; dis[v][now] &gt; dis[u][now] + edge[i].data) //不使用免费机会            {                dis[v][now] = dis[u][now] + edge[i].data;                q.push((Heap){v, dis[v][now], now});            }        }    }}</code></pre><h1 id="解法二-不推荐-（真·分层图）"><a href="#解法二-不推荐-（真·分层图）" class="headerlink" title="解法二 不推荐 （真·分层图）"></a>解法二 不推荐 <del>（真·分层图）</del></h1><p>这种做法很好写，也很好理解，不过浪费时空：</p><p>一下是几张张评测时的图片：</p><blockquote><p>做法一<br><img src="/10/分层图最短路小记/liuzhe.png" alt="liuzhe"></p><p>做法二<br><img src="/10/分层图最短路小记/payphone.png" alt="payphone"></p></blockquote><p>思想大致是：</p><p>我们如果有k次免费的机会，那我们就建k层图。</p><p>各层内部正常连边，各层之间从上到下连权值为0的边。每向下跑一层，就相当于免费使用一次机会。</p><p>代码不太重要就不贴了<del>其实不会写（</del>，可以去<a href="https://payphone-x.github.io/2019/10/14/luoguP4568/" target="_blank" rel="noopener">Payphone—X同学的Blog</a>康。</p><h1 id="Code-For-JLOI2011"><a href="#Code-For-JLOI2011" class="headerlink" title="Code For JLOI2011"></a>Code For JLOI2011</h1><pre><code class="lang-cpp">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define maxn 50005#define endl &#39;\n&#39;using namespace std;struct node{    int to, next, data;} edge[maxn &lt;&lt; 1];int head[maxn], num, n, m, k, s, t;int vis[maxn][11], dis[maxn][11];inline void add_edge(int from, int to, int data){    edge[++num].next = head[from];    edge[num].to = to;    edge[num].data = data;    head[from] = num;}struct Heap{    int u, v, now;    bool operator&lt;(const Heap &amp;b) const    {        return v &gt; b.v;    }};inline void dijkstra(int x){    dis[x][0] = 0;    priority_queue&lt;Heap&gt; q;    q.push((Heap){x, 0, 0});    while (!q.empty())    {        int u = q.top().u;        int now = q.top().now;        q.pop();        if (vis[u][now])            continue;        vis[u][now] = true;        for (register int i = head[u]; i; i = edge[i].next)        {            int v = edge[i].to;            if (!vis[v][now + 1] &amp;&amp; now &lt; k &amp;&amp; dis[v][now + 1] &gt; dis[u][now])            {                dis[v][now + 1] = dis[u][now];                q.push((Heap){v, dis[v][now + 1], now + 1});            }            if (!vis[v][now] &amp;&amp; dis[v][now] &gt; dis[u][now] + edge[i].data)            {                dis[v][now] = dis[u][now] + edge[i].data;                q.push((Heap){v, dis[v][now], now});            }        }    }}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s &gt;&gt; t;    for (register int i = 1; i &lt;= m; i++)    {        int x, y, v;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;        add_edge(x, y, v);        add_edge(y, x, v);    }    for (register int i = 0; i &lt;= n; i++)        for (register int j = 0; j &lt;= k; j++)            dis[i][j] = 2147482333;    dijkstra(s);    int ans = 2147482333;    for (int i = 0; i &lt;= k; ++i)        ans = min(ans, dis[t][i]);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P2071座位安排题解</title>
      <link href="//articles/2019/10/%E6%B4%9B%E8%B0%B7P2071%E5%BA%A7%E4%BD%8D%E5%AE%89%E6%8E%92%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/10/%E6%B4%9B%E8%B0%B7P2071%E5%BA%A7%E4%BD%8D%E5%AE%89%E6%8E%92%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><del>一道二分图匹配模板题</del></p><p><a href="https://www.luogu.org/problem/P2071" target="_blank" rel="noopener">点我传送</a></p><a id="more"></a><h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>公元二零一四年四月十七日，小明参加了省赛，在一路上，他遇到了许多问题，请你帮他解决。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>已知车上有N排座位，有N*2个人参加省赛，每排座位只能坐两人，且每个人都有自己想坐的排数，问最多使多少人坐到自己想坐的位置。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行，一个正整数Ｎ。</p><p>第二行至第Ｎ*2+1行，每行两个正整数Si1，Si2，为每个人想坐的排数。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一个非负整数，为最多使得多少人满意。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code>41 21 31 21 31 32 41 32 3</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>7</code></pre><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于10%的数据 N≤10</p><p>对于30%的数据 N≤50</p><p>对于60%的数据 N≤200</p><p>对于100%的数据 N≤2000</p><p>算法提示：二分图的最大匹配</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题一看题面就知道是二分图，于是我想都没想就开始打板子（因为太像板子题了）。调了半天才发现这里点和点之间的对应关系不想二分图板子那样是单一的：</p><blockquote><p>每排座位只能坐两人</p></blockquote><p>emmmmm，这要怎末办呢。</p><p>我们发现，我们把一排座位拆成两个点对答案丝毫不产生影响，所以我们可以邻接表开两倍，再存一倍的边。</p><p><strong>对了，这题据说卡邻接矩阵</strong></p><h1 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h1><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 4005using namespace std;struct node{    int to, next;} e[maxn &lt;&lt; 4];     //要多开两倍哦~~int head[maxn], num;int book[maxn], match[maxn], n, ans;void add_edge(int from, int to)     //临界表{    e[++num].next = head[from];    e[num].to = to;    head[from] = num;}inline bool dfs(int u)      //匈牙利算法板子{    for (register int i = head[u]; i; i = e[i].next)    {        int to = e[i].to;        if (!book[to])        {            book[to] = 1;            if (match[to] == 0 || dfs(match[to]))            {                match[to] = u;                return 1;            }        }    }    return 0;}int main(){    ios::sync_with_stdio(false);  //关同步    cin.tie(0);     //取消cin，cout绑定    cout.tie(0);    cin &gt;&gt; n;    for (register int i = 1; i &lt;= (n &lt;&lt; 1); i++)    {        int x, y;        cin &gt;&gt; x &gt;&gt; y;        add_edge(i, y);       //把座位拆开        add_edge(i, x);        add_edge(i, y + n);        add_edge(i, x + n);    }    for (register int i = 1; i &lt;= (n &lt;&lt; 1); i++)//统计答案    {        memset(book, 0, sizeof(book));        ans += dfs(i);    }    cout &lt;&lt; ans;    return 0;}</code></pre><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对拍模板</title>
      <link href="//articles/2019/10/%E5%AF%B9%E6%8B%8D%E6%A8%A1%E6%9D%BF/"/>
      <url>//articles/2019/10/%E5%AF%B9%E6%8B%8D%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>考场不对拍，爆零两行泪。</p><p><strong><em>__</em></strong>Payphone—X</p><p>想必大家都知道什么是对拍，我就不bb了。不会的同学右转google。</p><a id="more"></a><h1 id="考场版"><a href="#考场版" class="headerlink" title="考场版"></a>考场版</h1><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;int main(){    while(1)    {        system(&quot;data.exe &gt; data.in&quot;);        system(&quot;std.exe &lt; data.in &gt; std.out&quot;);        system(&quot;my.exe &lt; data.in &gt; my.out&quot;);        if(system(&quot;fc my.out std.out&quot;))            system(&quot;pause&quot;);    }}</code></pre><p>以下代码，改动了 Payphone_X 同学的代码，使测试的程序可以不用写文件输入输出，即拿即用。</p><h1 id="对拍模板-Windows"><a href="#对拍模板-Windows" class="headerlink" title="对拍模板 Windows"></a>对拍模板 Windows</h1><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#include&lt;windows.h&gt;#define ll long long#define I inlineusing namespace std;ll num , s , t;int main(){    while(true){        system(&quot;cls&quot;);        do{            num ++;            system(&quot;data.exe &gt; data.txt&quot;);            s = clock();            system(&quot;a.exe &lt; data.txt &gt; std.txt&quot;);            t = clock();            system(&quot;b.exe &lt; data.txt &gt; ans.txt&quot;);            if(system(&quot;fc std.txt ans.txt&quot;))                break;            else{                cout &lt;&lt; &quot;AC time&quot; &lt;&lt; &quot; &quot; &lt;&lt; t - s &lt;&lt; &quot;ms&quot; &lt;&lt; &quot;\n&quot;;                cout &lt;&lt; &quot;This is &quot; &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; &quot;AC&quot; &lt;&lt; &quot;\n&quot;;            }        }while(true);        cout &lt;&lt; &quot;WA time&quot; &lt;&lt; &quot; &quot; &lt;&lt; t - s &lt;&lt; &quot;ms&quot; &lt;&lt; &quot;\n&quot;;        cout &lt;&lt; &quot;This is &quot; &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; &quot;WA&quot; &lt;&lt; &quot;\n&quot;;        system(&quot;fc std.txt ans.txt&quot;);        system(&quot;pause &gt; nul&quot;);    }    return 0;}</code></pre><h1 id="对拍模板-Linux"><a href="#对拍模板-Linux" class="headerlink" title="对拍模板 Linux"></a>对拍模板 Linux</h1><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define ll long long#define I inlineusing namespace std;ll num , s , t;int main(){    while(true){        system(&quot;clear&quot;);        do{            num ++;            system(&quot;./data &gt; data.txt&quot;);            s = clock();            system(&quot;./a &lt; data.txt &gt; std.txt&quot;);            t = clock();            system(&quot;./b &lt; data.txt &gt; ans.txt&quot;);            if(system(&quot;diff std.txt ans.txt&quot;))                break;            else{                cout &lt;&lt; &quot;AC time&quot; &lt;&lt; &quot; &quot; &lt;&lt; t - s &lt;&lt; &quot;ms&quot; &lt;&lt; &quot;\n&quot;;                cout &lt;&lt; &quot;This is &quot; &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; &quot;AC&quot; &lt;&lt; &quot;\n&quot;;            }        }while(true);        cout &lt;&lt; &quot;WA time&quot; &lt;&lt; &quot; &quot; &lt;&lt; t - s &lt;&lt; &quot;ms&quot; &lt;&lt; &quot;\n&quot;;        cout &lt;&lt; &quot;This is &quot; &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; &quot;WA&quot; &lt;&lt; &quot;\n&quot;;        system(&quot;diff std.txt ans.txt&quot;);        cout &lt;&lt; &quot;按任意键继续&quot; &lt;&lt; &quot;\n&quot;;        getchar();    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1967货车运输题解</title>
      <link href="//articles/2019/10/%E6%B4%9B%E8%B0%B7P1967%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/10/%E6%B4%9B%E8%B0%B7P1967%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P1967" target="_blank" rel="noopener">点我传送</a></p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>AA国有nn座城市，编号从 11到nn，城市之间有 mm 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 qq 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行有两个用一个空格隔开的整数n,mn,m，表示 AA 国有nn 座城市和 mm 条道路。</p><p>接下来 mm行每行33个整数 x, y, zx,y,z，每两个整数之间用一个空格隔开，表示从 xx号城市到yy号城市有一条限重为 zz 的道路。注意： <strong>xx 不等于 yy，两座城市之间可能有多条道路</strong> 。</p><p>接下来一行有一个整数 q，表示有 q 辆货车需要运货。</p><p>接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： <strong>x 不等于 y</strong> 。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>共有 qq 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1−1。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code>4 31 2 42 3 33 1 131 31 41 3</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>3-13</code></pre><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于 30\%30%的数据，0 &lt; n &lt; 1,000,0 &lt; m &lt; 10,000,0 &lt; q&lt; 1,0000&lt;n&lt;1,000,0&lt;m&lt;10,000,0&lt;q&lt;1,000；</p><p>对于 60\%60%的数据，0 &lt; n &lt; 1,000,0 &lt; m &lt; 50,000,0 &lt; q&lt; 1,0000&lt;n&lt;1,000,0&lt;m&lt;50,000,0&lt;q&lt;1,000；</p><p>对于 100\%100%的数据，0 &lt; n &lt; 10,000,0 &lt; m &lt; 50,000,0 &lt; q&lt; 30,000,0 ≤ z ≤ 100,0000&lt;n&lt;10,000,0&lt;m&lt;50,000,0&lt;q&lt;30,000,0≤z≤100,000。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题解法很显然</p><p>我们跑一边最大生成树，然后求LCA。</p><p>有没有发现LCA不好维护最大载重，那我们用克鲁斯卡尔重构树即可。</p><p>先把边权从大到小排个序，然后建立一个克鲁斯卡尔重构树，对于每个询问，直接LCA便可，起点到终点在树上的LCA的点权即为答案。</p><p>不会Kruskal重构树戳<a href="https://blog.liuzhe.site/articles/2019/10/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/" target="_blank" rel="noopener">这里</a></p><h1 id="CODE-我十分毒瘤的用了树剖求LCA"><a href="#CODE-我十分毒瘤的用了树剖求LCA" class="headerlink" title="CODE (我十分毒瘤的用了树剖求LCA)"></a>CODE (我十分毒瘤的用了树剖求LCA)</h1><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#define endl &#39;\n&#39;#define maxn 200010using namespace std;struct node{    int from, to, data;    bool operator&lt;(const node &amp;b) const    {        return data &gt; b.data;    }} edge[maxn &lt;&lt; 2];struct node2{    int to, next;} e[maxn &lt;&lt; 2];int head[maxn], num = 0, a[maxn];int n, m, q, cnt;int fa[maxn], dep[maxn], top[maxn], _size[maxn], son[maxn], val[maxn], vis[maxn];inline void add_edge(int from, int to){    e[++num].next = head[from];    e[num].to = to;    head[from] = num;}int find(int x){    if (a[x] == x)        return x;    return a[x] = find(a[x]);}void dfs1(int u, int f, int deep){    vis[u] = true;    fa[u] = f;    dep[u] = deep;    _size[u] = 1;    for (int i = head[u]; i; i = e[i].next)    {        int v = e[i].to;        if (v == f)            continue;        dfs1(v, u, deep + 1);        _size[u] += _size[v];        if (_size[v] &gt; _size[son[u]])            son[u] = v;    }}void dfs2(int u, int t){    top[u] = t;    if (!son[u])        return;    dfs2(son[u], t);    for (int i = head[u]; i; i = e[i].next)    {        int v = e[i].to;        if (v != son[u] &amp;&amp; v != fa[u])            dfs2(v, v);    }}inline int lca(int a, int b){    while (top[a] != top[b])        if (dep[top[a]] &gt; dep[top[b]])            a = fa[top[a]];        else            b = fa[top[b]];    return dep[a] &lt; dep[b] ? a : b;}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; m;    cnt = n;    for (register int i = 1; i &lt;= n; i++)        a[i] = i;    for (register int i = 1; i &lt;= m; i++)        cin &gt;&gt; edge[i].from &gt;&gt; edge[i].to &gt;&gt; edge[i].data;    sort(edge + 1, edge + m + 1);    for (register int i = 1; i &lt;= m; i++)    {        int x = find(edge[i].from), y = find(edge[i].to);        if (x != y)        {            val[++cnt] = edge[i].data;            a[cnt] = a[x] = a[y] = cnt;            add_edge(x, cnt);            add_edge(cnt, x);            add_edge(y, cnt);            add_edge(cnt, y);        }    }    for (int i = 1; i &lt;= cnt; i++)        if (!vis[i])        {            int f = find(i);            dfs1(f, f, 1);            dfs2(f, f);        }    cin &gt;&gt; q;    while (q--)    {        int x, y;        cin &gt;&gt; x &gt;&gt; y;        if (find(x) != find(y))            cout &lt;&lt; &quot;-1\n&quot;;        else            cout &lt;&lt; val[lca(x, y)] &lt;&lt; endl;    }    return 0;}</code></pre><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Kruskal重构树</title>
      <link href="//articles/2019/10/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"/>
      <url>//articles/2019/10/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Kruskal重构树有个神奇的性质，使得我们可以用LCA求两点在生成树路径上的边权最大值的最最小值，或查询从某个点出发经过边权不超过x的边最远所能到达的节点。</p><a id="more"></a><h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><p>我们构建一个Kruskal重构树很简单，只需在Kruskal板子上稍加修改即可。</p><p>假设我们有这张图</p><p><img src="/10/Kruskal重构树/graph.png" alt="1"></p><p>它跑完克鲁斯卡尔(降序排序)之后是这样的：</p><p><img src="/10/Kruskal重构树/graph1.png" alt="2"></p><p>我们先将边权排序（排序的方式决定了这个Kruskal重构树的性质），Kruskal重构树在合并两个连通块时，不会像平常一样直接合并，而是新建一个节点，令这个节点的点权为连接的边的边权。</p><p><img src="/10/Kruskal重构树/graph2.png" alt="3"></p><p>便于理解，我们删掉原图的边:</p><p><img src="/10/Kruskal重构树/graph3.png" alt="4"></p><p>Kruskal重构树就这么完成了。</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>排序的方式决定了这个Kruskal重构树的性质</p><ul><li><blockquote><p>最小生成树上两个点之间的简单路径上边权最大值 = Kruskal 重构树上两点之间的 LCA 的权值。 -OI WIKI</p></blockquote></li><li><blockquote><p>到点 x 的简单路径上边权最大值 &lt;=val 的所有点  均在 Kruskal 重构树上的某一棵子树内，且恰好为该子树的所有叶子节点。 -OI WIKI</p></blockquote></li><li><blockquote><p>我们在 Kruskal 重构树上找到 x 到根的路径上权值 &lt;=val 的最浅的节点。显然这就是所有满足条件的节点所在的子树的根节点。 -OI WIKI</p></blockquote><p>  当然，你得降序排序。</p><p>  不然性质相反</p></li></ul><h1 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h1><pre><code class="lang-cpp">    for (register int i = 1; i &lt;= m; i++)    {        int x = find(edge[i].from), y = find(edge[i].to);        if (x != y)        {            val[++cnt] = edge[i].data;            a[cnt] = a[x] = a[y] = cnt;            add_edge(x, cnt);            add_edge(cnt, x);            add_edge(y, cnt);            add_edge(cnt, y);        }    }</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.org/problem/P1967#submit" target="_blank" rel="noopener">P1967 货车运输</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P2024食物链题解</title>
      <link href="//articles/2019/10/%E6%B4%9B%E8%B0%B7P2024%E9%A3%9F%E7%89%A9%E9%93%BE%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/10/%E6%B4%9B%E8%B0%B7P2024%E9%A3%9F%E7%89%A9%E9%93%BE%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P2024" target="_blank" rel="noopener">点我传送</a></p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。</p><p>现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道</p><p>它到底是哪一种。</p><p>有人用两种说法对这 N 个动物所构成的食物链关系进行描述：</p><p>第一种说法是“1 X Y”，表示 X 和 Y 是同类。</p><p>第二种说法是“2 X Y”，表示 X 吃 Y 。</p><p>此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真</p><p>的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><p>• 当前的话与前面的某些真的话冲突，就是假话</p><p>• 当前的话中 X 或 Y 比 N 大，就是假话</p><p>• 当前的话表示 X 吃 X，就是假话</p><p>你的任务是根据给定的 N 和 K 句话，输出假话的总数。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>从 eat.in 中输入数据</p><p>第一行两个整数，N，K，表示有 N 个动物，K 句话。</p><p>第二行开始每行一句话（按照题目要求，见样例）</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出到 eat.out 中</p><p>一行，一个整数，表示假话的总数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code>100 71 101 12 1 22 2 32 3 31 1 32 3 11 5 5</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>3</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题一看就是并查集辣，我们开三倍的并查集：</p><ul><li>第一倍存自身</li><li>第二倍存猎物</li><li>第三倍存天敌</li></ul><p>题目中还有一个条件：</p><blockquote><p>三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。</p></blockquote><p>也就是说：</p><p>如果 A 吃 B，B 吃 C。</p><p>那么 C 一定吃 A。</p><p>剩下就简单了。</p><h1 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h1><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define endl &#39;\n&#39;#define maxm 100005using namespace std;int fa[maxm * 3], n, k; //3倍并查集int x, y, opt;int find(int x){    if (fa[x] == x)        return x;    return fa[x] = find(fa[x]);}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; k;    for (int i = 1; i &lt;= n * 3; i++)        fa[i] = i; //初始化    int ans = 0;    for (register int i = 1; i &lt;= k; i++)    {        cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;        if (x &gt; n || y &gt; n)        {            ans++;            continue;        }        if (opt == 2) //x吃y        {            if (find(x) == find(y) || x == y) // 他们俩是同类            {                ans++;                continue;            }            else if (find(x + 2 * n) == find(y)) //y吃x            {                ans++;                continue;            }            fa[find(x)] = fa[find(y + 2 * n)];     // y的天敌是x的同类            fa[find(x + n)] = fa[find(y)];         // x吃的是y的同类            fa[find(x + 2 * n)] = fa[find(y + n)]; // y吃的是x的天敌        }        else        {            if (find(x + n) == find(y)) //x 吃 y            {                ans++;                continue;            }            else if (find(x + 2 * n) == find(y)) //y 吃 x            {                ans++;                continue;            }            fa[find(x)] = fa[find(y)]; //把他们的天敌，同类，猎物通通合并            fa[find(x + n)] = fa[find(y + n)];            fa[find(x + 2 * n)] = fa[find(y + 2 * n)];        }    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>珂朵莉树（ODT）详解</title>
      <link href="//articles/2019/10/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91%EF%BC%88ODT%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
      <url>//articles/2019/10/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91%EF%BC%88ODT%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class style="text-align:center; font-size:2.0em; font-weight:700"><p><span lang="ja" style="font-family:A-OTF A1 Mincho Std,Yu Mincho,SimSun,serif"><b>こんなにも、たくさんの幸せをあの人に分けてもらった<br>だから、きっと<br>今の、私は<br>誰が何と言おうと</b></span></p></div><span style="color:#81B9F0;"><div style="color:#81B9F0;font:bold 23px 楷体;text-shadow:#81CDF0 1px 1px 2px;" class="poem"><center><i><b><small>「うん。梦も叶ったし、いい思い出もできたし、思い残すことはもうないかな」</small></b></i></center></div></span><h3 id="liuzhe的珂学院"><a href="#liuzhe的珂学院" class="headerlink" title="liuzhe的珂学院"></a><strong><a href="https://chtholly.liuzhe.site" target="_blank" rel="noopener">liuzhe的珂学院</a></strong></h3><p>珂朵莉树保持复杂度主要依靠assign操作，所以题目中必须有区间赋值</p><p>还有很重要的一点：数据需纯随机</p><p>数据随机很重要，因为如果推平区间操作很少 / 很多单点，珂朵莉会被卡掉呀QwQ</p><a id="more"></a> <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=476748291&auto=0&height=32"></iframe><h3 id="珂朵莉树の前世今生"><a href="#珂朵莉树の前世今生" class="headerlink" title="珂朵莉树の前世今生"></a>珂朵莉树の前世今生</h3><p>珂朵莉树又名ODT（Old Driver Tree)</p><blockquote><p>因为珂朵莉树又名老司机树，所以珂朵莉 = 老司机<br>    ___Payphone—X</p></blockquote><p>在CF896C Willem, Chtholly and Seniorious中，她首次问世，作为一个非标程的数据结构，她拥有可以吊打标程的速度。</p><h3 id="珂朵莉树简介"><a href="#珂朵莉树简介" class="headerlink" title="珂朵莉树简介"></a>珂朵莉树简介</h3><p>珂朵莉树是一个十分暴力的数据结构，可以对区间进行修改，她有多暴力？她除了区间推平（即区间集体赋值）是板子之外，其余的全靠for O(n) 求。</p><p>她是用来维护一个STL set的，也就是对set进行各种骚操作，因为set是红黑树实现的，所以您如果够强，您也可以手写红黑树。</p><p>珂朵莉树的每一个节点和线段树一样，是存储一段区间的信息，不过与之不同的是，珂朵莉树的节点只存相同的元素。</p><ul><li>例如：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">区间</th><th style="text-align:left">p1</th><th style="text-align:left">p2</th><th style="text-align:left">p3</th><th style="text-align:left">p4</th><th style="text-align:left">p5</th><th style="text-align:left">p6</th><th style="text-align:left">p7</th><th style="text-align:left">p8</th><th style="text-align:left">p9</th></tr></thead><tbody><tr><td style="text-align:left">值</td><td style="text-align:left">5</td><td style="text-align:left">5</td><td style="text-align:left">5</td><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">8</td><td style="text-align:left">8</td><td style="text-align:left">8</td><td style="text-align:left">7</td></tr></tbody></table></div><p>珂朵莉树是这样存的：</p><ol><li>(p1 到 p3 的值全是5)</li><li>(p4 到 p4 的值全是1)</li><li>(p5 到 p5 的值全是2)</li><li>(p6 到 p8 的值全是8)</li><li>(p9 到 p9 的值全是7)</li></ol><p>就这样存完了</p><h3 id="珂朵莉树の基本操作"><a href="#珂朵莉树の基本操作" class="headerlink" title="珂朵莉树の基本操作"></a>珂朵莉树の基本操作</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>珂朵莉树因为要用到set，并对它进行骚操作，所以不可避免地要碰到指针和迭代器和毒瘤码风。</p><p>以下是结构体:</p><pre><code class="lang-cpp">struct node{    int l, r;   //区间左端点l，和右端点r    mutable long long val;  //区间的值    node(long long ll, long long rr = -1, LL vv = 0) //构造函数（定义临时节点或赋值用）    {        l = ll, r = rr, val = vv;    }    bool operator&lt;(const node &amp;b) const //运算符重载    {        return l &lt; b.l;    }};set&lt;node&gt; s;</code></pre><p>这里来解释一下什么是mutable.</p><p>mutable 是用来修饰一个 const 示例的部分可变的数据成员的。如果要说得更清晰一点，就是说 mutable 的出现，将 C++ 中的 const 的概念分成了两种。</p><p>二进制层面的 const，也就是「绝对的」常量，在任何情况下都不可修改（除非用 const_cast）。</p><p>引入 mutable 之后，C++ 可以有逻辑层面的 const，也就是对一个常量实例来说，从外部观察，它是常量而不可修改；但是内部可以有非常量的状态。<br>当然，所谓的「逻辑 const」，在 C++ 标准中并没有这一称呼。这只是为了方便理解，而创造出来的名词。</p><p>显而易见，mutable 只能用来修饰类的数据成员；而被 mutable 修饰的数据成员，可以在 const 成员函数中修改。</p><p>也就是说，只要定义了，mutable类型，加上迭代器，我们就可以不通过insert，push等操作修改set内部的元素，可以直接使用类似数组修改的办法修改set中的值辣！</p><h4 id="珂朵莉树の返回“下标”-指针-操作"><a href="#珂朵莉树の返回“下标”-指针-操作" class="headerlink" title="珂朵莉树の返回“下标”(指针)操作"></a>珂朵莉树の返回“下标”(指针)操作</h4><p>我们假如要修改一段区间，而这段区间不可能正好在珂朵莉树的一个节点上，这要怎么办呢，这时后我们要写一个函数split（pos），把节点拆开，拆成l~pos-1,pos~r。</p><p>举个栗子理解一下：这里用(l,r,val)来表示一个节点</p><p>设原节点按照set的排序顺序为(1,2,1), (3,6,2), (7,7,3)</p><p>那么split(5)操作后的节点序列就变为(1,2,1), (3,4,2), (5,6,2), (7,7,3)</p><pre><code class="lang-cpp">#define IT set&lt;chtholly&gt;::iterator // (1)inline IT split(int pos){    IT it = s.lower_bound(node(pos));    if (it != s.end() &amp;&amp; pos == it-&gt;l)        return it;    --it;   // (2)    int L = it-&gt;l, R = it-&gt;r;     long long val = it-&gt;val;    s.erase(it);         //删除原节点    s.insert(node(L, pos - 1, val));  //分裂原节点    return s.insert(node(pos, R, val)).first; //返回pos~r点的指针}</code></pre><p>这里返回的是代表[pos,r]区间的节点的迭代器，方便于其他操作。</p><ul><li><p>(1): emmmmm，这就是传说中的STL迭代器了，没了他你就不能访问STL容器中的内部元素了。</p></li><li><p>(2): 这里的lower_bound不是普通的二分查找，他返回第一个不小于pos的l，也就是说l&lt;=pos，所以要么it是set的右端点，要么pos恰好等于l，否则由于lower_bound返回第一个不小于pos的l，所以pos所在位置的指针一定在l后面，令it—即可。</p></li></ul><h4 id="珂朵莉树の推平操作"><a href="#珂朵莉树の推平操作" class="headerlink" title="珂朵莉树の推平操作"></a>珂朵莉树の推平操作</h4><p>这个非常简单啦，就短短几行代码。</p><pre><code class="lang-cpp">inline void assign(long long l, long long r, long long x){    IT itr = split(r + 1), itl = split(l);    tree.erase(itl, itr);   //删掉这俩区间    tree.insert(node(l, r, x));  //新建一个}</code></pre><p>为什么要先split出r+1呢？</p><p>因为如果先split出l，再split出r+1，之前的itl可能就不是l对应的迭代器了。</p><h3 id="珂朵莉树の其他暴力操作"><a href="#珂朵莉树の其他暴力操作" class="headerlink" title="珂朵莉树の其他暴力操作"></a>珂朵莉树の其他<del>暴力</del>操作</h3><ul><li><strong>以CF897C举例，大家自己体会体会有多暴力。</strong></li></ul><h4 id="区间加"><a href="#区间加" class="headerlink" title="区间加"></a>区间加</h4><p>暴力一个个加</p><pre><code class="lang-cpp">inline void add(long long l, long long r, long long x){    IT itr = split(r + 1), itl = split(l);    for (IT it = itl; it != itr; it++)        it-&gt;val += x;}</code></pre><h4 id="区间第k小"><a href="#区间第k小" class="headerlink" title="区间第k小"></a>区间第k小</h4><p>暴力取出后排序</p><pre><code class="lang-cpp">inline long long k_small(long long l, long long r, long long x){    vector&lt;pair&lt;LL, int&gt;&gt; a;    IT itr = split(r + 1), itl = split(l);    for (IT it = itl; it != itr; it++)        a.push_back(pair&lt;LL, int&gt;(it-&gt;val, it-&gt;r - it-&gt;l + 1));    sort(a.begin(), a.end());    for (vector&lt;pair&lt;LL, int&gt;&gt;::iterator it = a.begin(); it != a.end(); it++)    {        x -= it-&gt;second;        if (x &lt;= 0)            return it-&gt;first;    }}</code></pre><h4 id="珂朵莉树暴力通用模板"><a href="#珂朵莉树暴力通用模板" class="headerlink" title="珂朵莉树暴力通用模板"></a>珂朵莉树暴力通用模板</h4><pre><code class="lang-cpp">void performance(int l, int r) {  IT itr = split(r + 1), itl = split(l);  for (IT it = itl; it != itr; it++) {    // Perform Operations here  }}</code></pre><h3 id="CF896C-code"><a href="#CF896C-code" class="headerlink" title="CF896C code"></a>CF896C code</h3><pre><code class="lang-cpp">#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#define IT set&lt;chtholly&gt;::iterator //方便写代码#define maxn 10000#define mod %typedef long long LL;using namespace std;namespace chthollyTree{struct chtholly{    long long l, r;    mutable long long val;    chtholly(long long ll, long long rr = -1, LL vv = 0) //构造函数（定义临时节点或赋值用）    {        l = ll, r = rr, val = vv;    }    bool operator&lt;(const chtholly &amp;b) const //运算符重载    {        return l &lt; b.l;    }};set&lt;chtholly&gt; tree;inline IT split(long long pos){    IT it = tree.lower_bound(chtholly(pos));    if (it != tree.end() &amp;&amp; pos == it-&gt;l)        return it;    --it;    long long L = it-&gt;l, R = it-&gt;r;    LL val = it-&gt;val;    tree.erase(it);    tree.insert(chtholly(L, pos - 1, val));    return tree.insert(chtholly(pos, R, val)).first;}inline void assign(long long l, long long r, long long x){    IT itr = split(r + 1), itl = split(l);    tree.erase(itl, itr);    tree.insert(chtholly(l, r, x));}inline void add(long long l, long long r, long long x){    IT itr = split(r + 1), itl = split(l);    for (IT it = itl; it != itr; it++)        it-&gt;val += x;}inline long long k_small(long long l, long long r, long long x){    vector&lt;pair&lt;LL, int&gt;&gt; a;    IT itr = split(r + 1), itl = split(l);    for (IT it = itl; it != itr; it++)        a.push_back(pair&lt;LL, int&gt;(it-&gt;val, it-&gt;r - it-&gt;l + 1));    sort(a.begin(), a.end());    for (vector&lt;pair&lt;LL, int&gt;&gt;::iterator it = a.begin(); it != a.end(); it++)    {        x -= it-&gt;second;        if (x &lt;= 0)            return it-&gt;first;    }}inline LL qpow(LL x, long long y, long long m){    LL ans = 1;    x = x % m;    while (y)    {        if (y &amp; 1)            ans = ans * x % m;        x = x * x % m;        y &gt;&gt;= 1;    }    return ans;}inline LL pow(long long l, long long r, long long x, long long y){    IT itr = split(r + 1), itl = split(l);    long long ans = 0;    for (IT it = itl; it != itr; it++)        ans = ((ans + (LL)(it-&gt;r - it-&gt;l + 1) * qpow(it-&gt;val, (LL)x, (LL)y)) % y + y) % y;    return ans;}} // namespace chthollyTreeusing namespace std;LL n, m, seed, vmax;inline LL rnd(){    LL ret = seed;    seed = (seed * 7 + 13) mod 1000000007;    return ret;}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;    for (long long i = 1; i &lt;= n; i++)        chthollyTree::tree.insert(chthollyTree::chtholly(i, i, (rnd() % vmax) + 1));    long long x, y;    while (m--)    {        x = 0, y = 0;        long long op = (rnd() mod 4) + 1, l = (rnd() mod n) + 1, r = (rnd() mod n) + 1;        if (l &gt; r)            swap(l, r);        if (op == 3)            x = (rnd() mod(r - l + 1)) + 1;        else            x = (rnd() mod vmax) + 1;        if (op == 4)            y = (rnd() mod vmax) + 1;        switch (op)        {        case 1:            chthollyTree::add(l, r, x);            break;        case 2:            chthollyTree::assign(l, r, x);            break;        case 3:            cout &lt;&lt; chthollyTree::k_small(l, r, x) &lt;&lt; endl;            break;        case 4:            cout &lt;&lt; chthollyTree::pow(l, r, x, y) &lt;&lt; endl;            break;        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 毒瘤 </tag>
            
            <tag> 区间 </tag>
            
            <tag> 珂朵莉树 </tag>
            
            <tag> 暴力数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分—重链剖分小记</title>
      <link href="//articles/2019/10/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E2%80%94%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86%E5%B0%8F%E8%AE%B0/"/>
      <url>//articles/2019/10/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E2%80%94%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>树链剖分可以将一棵树剖为很多条链，这样据可以供其他的数据结构维护，（树剖/链剖）有多种形式，如 重链剖分 ， 长链剖分 和用于 Link/cut Tree 的剖分（有时被称作“实链剖分”），大多数情况下（没有特别说明时），“树链剖分”都指“重链剖分”，本文所讲的也是“重链剖分”。</p><a id="more"></a> <h3 id="树链剖分是做什么的"><a href="#树链剖分是做什么的" class="headerlink" title="树链剖分是做什么的"></a>树链剖分是做什么的</h3><p>为了便于理解，我从oi-wiki上引用些图文来解释（个人感觉解释的比较直观）：</p><blockquote><p>定义 重子节点 表示其子节点中子树最大的子结点。如果有相同的，任意取。如果没有子节点，就没有。</p><p>定义 轻子节点 表示剩余的子结点。</p><p>从这个结点到重子节点的边叫 重边 。</p><p>到其他轻子节点的边叫 轻边 。</p><p>若干条首尾衔接的重边构成 重链 。</p><p>把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。</p><p>看一张图就明白了</p></blockquote><p><img src="/10/树链剖分—重链剖分小记/hld.png" alt="hid"></p><p>它可以用于求LCA(据说比倍增的LCA快)，它还可以将一棵树拆成很多条链，方便线段树维护等。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>树链剖分代码不长，但是他要定义许多变量，emmmmmm，比较烦人，树链剖分的初始化就两个bfs。</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><pre><code class="lang-cpp">struct node{    int to, next;} edge[maxn];</code></pre><h4 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h4><pre><code class="lang-cpp">int fa[i]; //i节点的父亲int son[i]; //i节点的重儿子int d[i]; //i节点的深度int size[i]; //以i为根的子树结点个数int dfn[i]; //i节点在dfs树中的dfs序int top[i]; //i节点所在链的顶端节点的编号int rnk[i]; //i节点剖分以后的新结点编号</code></pre><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>重链剖分需要在两个dfs中预处理出这些数组</p><p>第一个bfs求的是 fa,son,d,size。</p><p>代码如下（还是很好理解的）：</p><pre><code class="lang-cpp">void dfs1(int u, int f, int deep){    fa[u] = f;    dep[u] = deep;    size[u] = 1;    for (int i = head[u]; i; i = edge[i].next)    {        int v = edge[i].to;        if (v == f)            continue;        dfs1(v, u, deep + 1);        size[u] += size[v];         //回溯        if (size[v] &gt; size[son[u]]) //贪心选择            son[u] = v;    }}</code></pre><blockquote><p>dfs跑完大概是这样的，大家可以手动模拟一下<br><img src="/10/树链剖分—重链剖分小记/v2-9c08dae6f0b1d00234b281ef96611d3c_hd.jpg" alt="1"></p></blockquote><p>第一个bfs求的则是剩下的</p><pre><code class="lang-cpp">void dfs2(int u, int t){    top[u] = t;    dfs[u] = ++cnt;    rnk[cnt] = u; //序号cnt对应节点u    if (!son[u])        return;    dfs2(son[u], t);    for (int i = head[u]; i; i = edge[i].next)    {        int v = edge[i].to;        if (v != son[u] &amp;&amp; v != f[u])            dfs2(v, v);    }}</code></pre><p><img src="/10/树链剖分—重链剖分小记/64629076_p0_master1200.jpg" alt="2"></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="1-求LCA"><a href="#1-求LCA" class="headerlink" title="1. 求LCA"></a>1. 求LCA</h4><p>让两个点不断向上跳到自己的链的顶端。一旦他们跳到了同一个链上，两个点中深度较小的点即为LCA。</p><p>上代码：</p><pre><code class="lang-cpp">inline int lca(int a, int b){    while (top[a] != top[b])        if (dep[top[a]] &gt; dep[top[b]])            a = fa[top[a]];        else            b = fa[top[b]];    return dep[a] &lt; dep[b] ? a : b;}</code></pre><p><a href="https://www.luogu.org/problem/P3379" target="_blank" rel="noopener">Luogu P3379 【模板】最近公共祖先（LCA）</a> 代码：</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int fa[500005];   //i节点的父亲int son[500005];  //i节点的重儿子int dep[500005];  //i节点的深度int size[500005]; //以i为根的子树结点个数int top[500005];  //i节点所在链的顶端节点的编号int cnt = 0;struct node{    int to, next;} edge[1000005];int head[500005], num = 0;void add_edge(int from, int to){    num++;    edge[num].next = head[from];    head[from] = num;    edge[num].to = to;}void dfs1(int u, int f, int deep){    fa[u] = f;    dep[u] = deep;    size[u] = 1;    for (int i = head[u]; i; i = edge[i].next)    {        int v = edge[i].to;        if (v == f)            continue;        dfs1(v, u, deep + 1);        size[u] += size[v];         //回溯        if (size[v] &gt; size[son[u]]) //贪心选择            son[u] = v;    }}void dfs2(int u, int t){    top[u] = t;    if (!son[u])        return;    dfs2(son[u], t);    for (int i = head[u]; i; i = edge[i].next)    {        int v = edge[i].to;        if (v != son[u] &amp;&amp; v != fa[u])            dfs2(v, v);    }}inline int lca(int a, int b){    while (top[a] != top[b])        if (dep[top[a]] &gt; dep[top[b]])            a = fa[top[a]];        else            b = fa[top[b]];    return dep[a] &lt; dep[b] ? a : b;}int n, m, s;int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;    for (int i = 1; i &lt; n; i++)    {        int x, y;        cin &gt;&gt; x &gt;&gt; y;        add_edge(x, y);        add_edge(y, x);    }    dfs1(s, s, 1);    dfs2(s, s);    for (int i = 1; i &lt;= m; i++)    {        int x, y;        cin &gt;&gt; x &gt;&gt; y;        cout &lt;&lt; lca(x, y) &lt;&lt; endl;    }    return 0;}</code></pre><p>先留个坑，后续会更</p>]]></content>
      
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分答案思想小记——洛谷P2678-跳石头-题解</title>
      <link href="//articles/2019/09/%E6%B4%9B%E8%B0%B7P2678-%E8%B7%B3%E7%9F%B3%E5%A4%B4-%E9%A2%98%E8%A7%A3/"/>
      <url>//articles/2019/09/%E6%B4%9B%E8%B0%B7P2678-%E8%B7%B3%E7%9F%B3%E5%A4%B4-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>因本人不会二分答案，特写此题解以记之。</p><a id="more"></a><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><p>模板code：</p><pre><code class="lang-cpp">int Binary-Search(int find,int l,int r){    while (l &lt;= r)    {        int mid = (l+r)&gt;&gt;1; // 等同于（l+r）÷ 2        if(a[mid] == find) return mid; //找到答案返回下标        if(find &gt; a[mid])            l = mid + 1;        else r = mid - 1;    }    return -1;}</code></pre><h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><p>二分答案，顾名思义，就是对答案进行二分。然后判断答案是否成立便可。</p><ul><li>emmmm，一般说，如果答案上说有类似于“求答案最大值最小”或“最小值最大”之类的，先考虑二分答案。</li></ul><p>因为答案是一个单峰函数（<del>详见高中数学必修一</del>)，所可以考虑对答案进行二分，我们先取0～终点的距离的一半，我们康康能跳过的石头的距离不大于这个值的石头个数符不符合给出的m，若符合，我们可以考虑把这个二分出的距离加大，既（l=mid+1，取二分的右半边），以逼近答案。否则缩小范围。</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;cmath&gt;#define maxn 500005using namespace std;int a[maxn] = {}, l, n, m, d, r, ans;inline bool judge(int x)cpp{    int tot = 0;    int now = 0;    for (register int i = 1; i &lt;= n + 1; i++)    {        if (a[i] - a[now] &lt; x)            tot++;        else            now = i;        if (tot &gt; m)            return false;    }    return true;}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; d &gt;&gt; n &gt;&gt; m;    for (register int i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i];    a[n + 1] = d;    l = 1;    r = d;    while (l &lt;= r)    {        int mid = (r + l) &gt;&gt; 1;        if (judge(mid))        {            ans = mid;            l = mid + 1;        }        else            r = mid - 1;    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS,BFS,ID,IDA*等搜索算法简介</title>
      <link href="//articles/2019/08/DFS-BFS-ID-IDA-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
      <url>//articles/2019/08/DFS-BFS-ID-IDA-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本节的 A , A* 暂无代码实现</p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搜索一般分为盲目搜索和启发式搜索</p><p>下面列举以下OI常用的盲目搜索:</p><ol><li>迪杰斯特拉</li><li>SPFA</li><li>BFS</li><li>DFS</li><li>双向BFS</li><li>迭代加深搜索(ID)</li></ol><p>下面列举以下OI常用的启发式搜索:</p><ol><li>最佳优先搜索(A)</li><li>A*</li><li>IDA<strong>* (ID + A </strong> *  ??? (大雾) )</li></ol><p>什么?? 我用了这么多年的bfs是盲目是搜索!!!</p><blockquote><p>举个例子，假如你在学校操场，老师叫你去国旗那集合，你会怎么走？<br>假设你是瞎子，你看不到周围，那如果你运气差，那你可能需要把整个操场走完才能找到国旗。这便是盲目式搜索，即使知道目标地点，你可能也要走完整个地图。<br>假设你眼睛没问题，你看得到国旗，那我们只需要向着国旗的方向走就行了，我们不会傻到往国旗相反反向走，那没有意义。<br>这种有目的的走法，便被称为启发式的。</p></blockquote><p>给个图您就明白了</p><p>左图是广搜 右图是最佳优先搜索(A):</p><p><img src="/08/DFS-BFS-ID-IDA-搜索算法简介/1.gif" alt="1"></p><p>下图是A* 搜索:</p><p><img src="/08/DFS-BFS-ID-IDA-搜索算法简介/Astar.gif" alt="astar"></p><p><a href="http://www.webhek.com/post/pathfinding.html" target="_blank" rel="noopener">动画展示各种路径搜索算法</a></p><h1 id="搜索算法浅谈"><a href="#搜索算法浅谈" class="headerlink" title="搜索算法浅谈"></a>搜索算法浅谈</h1><h2 id="关于DFS"><a href="#关于DFS" class="headerlink" title="关于DFS"></a>关于DFS</h2><p>这东西应该是妇孺皆知,<del>不知道的话您就可以退役了</del>.</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>我就不多讲了,说一下她的优点:</p><ol><li>代码简洁易于编写</li><li>可以方便的加一些剪枝</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>浪费时间,要用剪枝来优化</li></ol><p>为什么浪费时间呢?</p><p>看个图你就明白了:</p><p><img src="/08/DFS-BFS-ID-IDA-搜索算法简介/dfs.png" alt="dfs"></p><p>不要随便加剪枝,有些剪枝用处很小,不会节约太多时间,但是你的程序将会对她进行无数次特判,这个代价可比你剪枝节约的时间高多了</p><p>代码大体框架:</p><pre><code class="lang-cpp">void dfs(状态A){    if(A不合法)        return;    if(A为目标状态)        输出或记录路径    if(A不为目标状态)        dfs(A+Δ )  }</code></pre><h2 id="关于BFS"><a href="#关于BFS" class="headerlink" title="关于BFS"></a>关于BFS</h2><p>这东西也应该是妇孺皆知,<del>不知道的话您就又可以退役了</del>.</p><p>bfs适合目标明确的情况,是典型的空间换时间的算法.</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>我就不多讲了,说一下他的优点 (又是这句话(大雾</p><ol><li>一般比dfs快</li><li><del>难写(有些人就爱写BFS)</del></li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>难写</li><li>十分占空间</li></ol><p>代码大体框架:</p><pre><code class="lang-cpp">q.push(head);while(!q.empty()){    temp=q.front();    q.pop();    if(tempÎ为目标状态)        输出或记录    if(temp不合法 )        continue;    if(temp合法)        q.push(temp+¦Δ ); }</code></pre><h2 id="关于迭代加深搜索-ID-与IDA"><a href="#关于迭代加深搜索-ID-与IDA" class="headerlink" title="关于迭代加深搜索(ID)与IDA*"></a>关于迭代加深搜索(ID)与IDA*</h2><p>蓦然回首,再去看一眼上图:</p><p><img src="/08/DFS-BFS-ID-IDA-搜索算法简介/dfs.png" alt="dfs"></p><p>我们发现如果现在的路的深度没有上限，即没有底，那么直接DFS就回不来了,但终点就在第二层,怎么办?</p><p>我们设一个深度d每次搜到d层就回头去搜别的分支,如果没搜到就让d++,再从头搜一次.这种算法思想上相当于是DFS+BFS的合体,但是缺点很明显，重复遍历解答树上层多次，造成巨大浪费。</p><p>于是我们伟大的前辈们开动脑筋,发明了 <strong>IDA*</strong>.</p><blockquote><p>IDA star多了评估函数（或者说剪枝），每次预估如果这条路如果继续下去也无法到达终点，则放弃这条路（剪枝的一种，即最优性剪枝）。IDA star原理实现起来简单，非常方便，但难的地方是评估函数的编写，足够好的评估函数可以避免走更多的不归路，如果评估函数太差或者没有评估函数，那会退化到迭代加深搜索那种浪费程度。</p></blockquote><p>评估函数f = g + h</p><p>g是已经走的</p><p>h是估计代价</p><p>代码大致如下</p><pre><code class="lang-cpp">//1代表墙，0代表空地，2代表终点int G[maxn][maxn];int n, m;int endx, endy;int maxd;const int dx[4] = { -1, 1, 0, 0 };const int dy[4] = { 0, 0, -1, 1 };namespace ida{    bool dfs(int x, int y, int d);    inline int h(int x, int y);    bool ida_star(int x, int y, int d)    {        if (d == maxd)                   //是否搜到答案        {            if (G[x][y] == 2)                return true;            return false;        }        int f = h(x, y) + d;          //评估函数        if (f &gt; maxd)                //maxd为最大深度            return false;    //尝试向左，向右,向上，向下走        for (int i = 0; i &lt; 4; i++)        {            int next_x = x + dx[i];            int next_y = y + dy[i];            if (next_x &gt; n || next_x &lt; 1 || next_y &gt; m || next_y &lt; 1 || G[next_x][next_y] == 1)                continue;            if (ida_star(next_x, next_y, d + 1))                return true;        }        return false;    }    inline int h(int x, int y)    {        return abs(x - endx) + abs(y - endy);    }}</code></pre><p>调用:</p><pre><code class="lang-cpp">    //枚举步数，最少多少步能到达目标     for(maxd = 1; ;maxd++)        if(dfs(0, 0, 0))        {            cout &lt;&lt; maxd &lt;&lt; endl;             break;        }</code></pre><h3 id="迭代加深-amp-amp-IDA-star只适用于有解的情况"><a href="#迭代加深-amp-amp-IDA-star只适用于有解的情况" class="headerlink" title="迭代加深&amp;&amp;IDA_star只适用于有解的情况"></a>迭代加深&amp;&amp;IDA_star只适用于有解的情况</h3><p><a href="https://github.com/liu-zhe/IDA_star" target="_blank" rel="noopener">我的ida_star演示代码</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><p><a href="https://blog.csdn.net/ljt735029684/article/details/78945098" target="_blank" rel="noopener">对于DFS，BFS，A与IDA*等寻路算法的总结跟感悟</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 毒瘤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长上升子序列</title>
      <link href="//articles/2019/07/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>//articles/2019/07/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是第二篇题解呢</p></blockquote><p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1281" target="_blank" rel="noopener">点我传送</a></p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><h2 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h2><p>一个数的序列bi，当b1&lt;b2&lt;…&lt;bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1,a2,…,aN)，我们可以得到一些上升的子序列(ai1,ai2,…,aiK)，这里1≤i1&lt;i2&lt;…&lt;iK≤N。比如，对于序列(1,7,3,5,9,4,8)，有它的一些上升子序列，如(1,7),(3,4,8)等等。这些子序列中最长的长度是4，比如子序列(1,3,5,8)。</p><p>你的任务，就是对于给定的序列，求出最长上升子序列的长度。</p><h2 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h2><p>输入的第一行是序列的长度N(1≤N≤1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。</p><h2 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h2><p>最长上升子序列的长度。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>我们的目标是求出最长的不连续的上升数列,那么我们开一个数组f[i],存以i结尾的数列长度;</p><p>那么,对于每一个数i,我们从她前面找一个比她小的数字j,判断和她连接后长度是否比当前长度长,是的话则替换fi的值.</p><p>方程式大致如下</p><p>fi = max(fj+1,fi) | fi &gt; fj</p><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#define maxn 100005using namespace std;int n, a[maxn] = {};int f[maxn] = {};int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)    {        cin &gt;&gt; a[i];        f[i] = 1;    }    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt; i; j++)        {            if (a[i] &gt; a[j])            {                f[i] = max(f[j] + 1, f[i]);            }        }    cout &lt;&lt; *std::max_element(f + 1, f + n + 1) &lt;&lt; endl;    return 0;}</code></pre><h1 id="优化-update-2019-10-05"><a href="#优化-update-2019-10-05" class="headerlink" title="优化 update 2019.10.05"></a>优化 update 2019.10.05</h1><p>LIS其实可以优化到O(nlogn)</p><p>有这么一个串：</p><p>3 1 5 2 7 6</p><p>我们考虑开一个数组记录最长子串而不是记录以i结尾的串长度。</p><pre><code class="lang-cpp">for (register int i = 1; i &lt;= n; i++){    if(....)        .....    else        .....}</code></pre><p>我们每添加一个数，比较他与我们记录最长子串的数组最后一个数大还是小，如果大就直接加入数组末尾。</p><pre><code class="lang-cpp">for (register int i = 1; i &lt;= n; i++){    if(a[i] &gt; s[len])        s[++len] = a[i];    else        .....}</code></pre><p>不然我们就二分找一个比a[i]大的最小元素，然后替换，如果它不会更新答案，那么它也就不会更新到末尾，也就不会影响答案。还有我们求的是长度，和里面的元素无关。</p><pre><code class="lang-cpp">int lower_bound(int x){    int l = 1, r = len;    while (l &lt; r)    {        int mid = (l + r) &gt;&gt; 1;        if (s[mid] &lt; x)            l = mid + 1;        else            r = mid;    }    return l;}for (register int i = 1; i &lt;= n; i++){    if(a[i] &gt; s[len])        s[++len] = a[i];    else        s[lower_bound(a[i])] = a[i];}cout &lt;&lt; len;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p1840 Axis_NOI导刊2011提高（05）题解</title>
      <link href="//articles/2019/07/Axis-NOI%E5%AF%BC%E5%88%8A2011%E6%8F%90%E9%AB%98%EF%BC%8805%EF%BC%89/"/>
      <url>//articles/2019/07/Axis-NOI%E5%AF%BC%E5%88%8A2011%E6%8F%90%E9%AB%98%EF%BC%8805%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是我的第一篇题解呢</p></blockquote><p><a href="https://www.luogu.org/problem/P1840" target="_blank" rel="noopener">点我传送</a></p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一条数轴上有N个点，分别是1—N。一开始所有的点都被染成黑色。接着我们进行M次操作，第i次操作将[Li，Ri]这些点染成白色。请输出每个操作执行后剩余黑色点的个数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行为N和M。下面M行每行两个数Li、Ri。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出M行，为每次操作后剩余黑色点的个数。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我们要对一段区间进行处理，每次把l～r染黑，我们可以考虑用线段树维护区间内有多少黑色，lazytag标记将l～r全部染白。</p><p>接下来就是板子了。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;#define root 1, n, 1#define lson l, m, rt * 2#define rson m + 1, r, rt * 2 + 1#define now_node l, r, rtconst int maxn = 200005;long long m, n, z[maxn * 4] = {0}, flag[maxn * 4] = {0};void update(int rt){    z[rt] = z[rt * 2] + z[rt * 2 + 1]; }void build(int l, int r, int rt) //建立一棵线段树{    if (l == r) //当左端点=右端点时，就表示它是一个叶子节点，这时我们就给它赋值    {        z[rt] = 1;        return;    }    int m = (l + r) / 2; //二分当前区间    build(lson);         //左边一段作为左子树，递归建立左子树    build(rson);         //右边一段作为右子树，递归建立右子树    update(rt);          //将左右子树的修改应用于当前节点}void add(int l, int r, int rt) {    z[rt] = 0;    flag[rt] = 1;}void push_down(int l, int r, int rt) //在询问时，把标记下放{    if (flag[rt] != 0)    {        int m = (l + r) / 2;        add(lson); //打左儿子        add(rson); //打右儿子 233        flag[rt] = 0;        //标记清零    }}void modify(int l, int r, int rt, int findl, int findr) //修改findl~findr区间的值，把它们都加上v{    if (findl == l &amp;&amp; r == findr) //将区间的修改应用于它的每一个子节点    {        add(now_node);        return;    }    push_down(now_node);    int m = (l + r) / 2; //二分当前区间    if (findl &lt;= m)      //要修改的区间在左子树上    {        if (m &lt; findr) //特判：要改的区间贯穿左右子树        {            modify(lson, findl, m);     //在左子树上改findl~m这段            modify(rson, m + 1, findr); //在右子树上改m+1~findr这段        }        else            modify(lson, findl, findr);    }    else        modify(rson, findl, findr); //要找的区间在右子树上    update(rt);}long long query(int l, int r, int rt, int findl, int findr) //询问某段区间的和 findl表示要询问的区间的左端点，findr表示要询问的区间的右端点{    if (findl == l &amp;&amp; r == findr)        return z[rt]; //当前端点等于要找的端点时 返回    push_down(now_node);    int m = (l + r) / 2; //二分当前区间    if (findl &lt;= m)      //要找的区间在左子树上    {        if (m &lt; findr)            return query(lson, findl, m) + query(rson, m + 1, findr); //特判：要找的区间贯穿左右子树        else            return query(lson, findl, findr);    }    else        return query(rson, findl, findr); //要找的区间在右子树上}int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cin &gt;&gt; n &gt;&gt; m; //线段树区间的长度为n，有次操作    build(root);   //从根结点开始建立线段树    for (register int i = 1; i &lt;= m; i++)    {        int l,r;        cin &gt;&gt; l&gt;&gt;r;        modify(root, l, r);        cout &lt;&lt; query(root, 1, n)&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载－KMP算法</title>
      <link href="//articles/2019/01/%E8%BD%AC%E8%BD%BD%EF%BC%8DKMP%E7%AE%97%E6%B3%95/"/>
      <url>//articles/2019/01/%E8%BD%AC%E8%BD%BD%EF%BC%8DKMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>有些算法，适合从它产生的动机，如何设计与解决问题这样正向地去介绍。但KMP算法真的不适合这样去学。最好的办法是先搞清楚它所用的数据结构是什么，再搞清楚怎么用，最后为什么的问题就会有恍然大悟的感觉。我试着从这个思路再介绍一下。大家只需要记住一点，PMT是什么东西。然后自己临时推这个算法也是能推出来的，完全不需要死记硬背。KMP算法的核心，是一个被称为部分匹配表(Partial Match Table)的数组。我觉得理解KMP的最大障碍就是很多人在看了很多关于KMP的文章之后，仍然搞不懂PMT中的值代表了什么意思。这里我们抛开所有的枝枝蔓蔓，先来解释一下这个数据到底是什么。对于字符串“abababca”，它的PMT如下表所示：</p><p><img src="/01/转载－KMP算法/1.jpg" alt="1"></p><p>就像例子中所示的，如果待匹配的模式字符串有8个字符，那么PMT就会有8个值。</p><p>我先解释一下字符串的前缀和后缀。如果字符串A和B，存在A=BS，其中S是任意的非空字符串，那就称B为A的前缀。例如，”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。同样可以定义后缀A=SB， 其中S是任意的非空字符串，那就称B为A的后缀，例如，”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。要注意的是，字符串本身并不是自己的后缀。</p><p>有了这个定义，就可以说明PMT中的值的意义了。<strong>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</strong>。例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长 度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p><p>好了，解释清楚这个表是什么之后，我们再来看如何使用这个表来加速字符串的查找，以及这样用的道理是什么。如图 1.12 所示，要在主字符串”ababababca”中查找模式字符串”abababca”。如果在 j 处字符不匹配，那么由于前边所说的模式字符串 PMT 的性质，主字符串中 i 指针之前的 PMT[j −1] 位就一定与模式字符串的第 0 位至第 PMT[j−1] 位是相同的。这是因为主字符串在 i 位失配，也就意味着主字符串从 i−j 到 i 这一段是与模式字符串的 0 到 j 这一段是完全相同的。而我们上面也解释了，模式字符串从 0 到 j−1 ，在这个例子中就是”ababab”，其前缀集合与后缀集合的交集的最长元素为”abab”， 长度为4。所以就可以断言，主字符串中i指针之前的 4 位一定与模式字符串的第0位至第 4 位是相同的，即长度为 4 的后缀与前缀相同。这样一来，我们就可以将这些字符段的比较省略掉。具体的做法是，保持i指针不动，然后将j指针指向模式字符串的PMT[j −1]位即可。</p><p>简言之，以图中的例子来说，在 i 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串i之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p><p><img src="/01/转载－KMP算法/2.jpg" alt="2"></p><p>有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，所以为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。下面给出根据next数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把PMT进行向右偏移时，第0位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next数组如下表所示。</p><p><img src="/01/转载－KMP算法/3.jpg" alt="3"></p><pre><code class="lang-cpp">int KMP(char * t, char * p) {    int i = 0;     int j = 0;    while (i &lt; strlen(t) &amp;&amp; j &lt; strlen(p))    {        if (j == -1 || t[i] == p[j])         {            i++;                   j++;        }         else                    j = next[j];        }    if (j == strlen(p))       return i - j;    else        return -1;}</code></pre><p>好了，讲到这里，其实KMP算法的主体就已经讲解完了。你会发现，其实KMP算法的动机是很简单的，解决的方案也很简单。远没有很多教材和算法书里所讲的那么乱七八糟，只要搞明白了PMT的意义，其实整个算法都迎刃而解。</p><p>现在，我们再看一下如何编程快速求得next数组。其实，求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。</p><p>具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。如下图所示。</p><p><img src="/01/转载－KMP算法/4.jpg" alt="4"></p><p><img src="/01/转载－KMP算法/5.jpg" alt="5"></p><p><img src="/01/转载－KMP算法/6.jpg" alt="6"></p><p><img src="/01/转载－KMP算法/7.jpg" alt="7"></p><p><img src="/01/转载－KMP算法/8.jpg" alt="8"></p><p>求next数组值的程序如下所示：</p><pre><code class="lang-cpp">void getNext(char * p, int * next){    next[0] = -1;    int i = 0, j = -1;    while (i &lt; strlen(p))    {        if (j == -1 || p[i] == p[j])        {            ++i;            ++j;            next[i] = j;        }            else            j = next[j];    }}</code></pre><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>作者：海纳<br>链接：<a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="noopener">https://www.zhihu.com/question/21923021/answer/281346746</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01背包小记</title>
      <link href="//articles/2019/01/01%E8%83%8C%E5%8C%85%E5%B0%8F%E8%AE%B0/"/>
      <url>//articles/2019/01/01%E8%83%8C%E5%8C%85%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>感谢太阳大佬的讲解</p></blockquote><p>0-1背包是一个经典的DP问题（主要是OI考）<br><a id="more"></a> </p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>有N件物品和一个容量为V 的背包。放入第i件物品耗费的背包容量是W[i]，得到的价值是C[i]。求将哪些物品装入背包可使价值总和最大，而每件物品只有一个，可以选择不放。</p><p>0-1背包是其他背包问题的基础</p><h3 id="无优化版本"><a href="#无优化版本" class="headerlink" title="无优化版本"></a>无优化版本</h3><p>我们用一个数组 f[i][v]来表示这个虚拟的背包，表示前i件物品恰放入一个容量为v的背包可 以获得的最大价值。</p><p>对于每一种物品，我们可以选或者不选，不选的话呢一切状态不变，选的话呢，则背包的容量减去W[i]，背包里的物品价值加上C[i]。</p><p>于是我们可得到它的状态转移方程：</p><p>F[ⅈ][v]=max⁡(F[ⅈ−1][v],F[ⅈ−1][v−W[ⅈ]]+C[ⅈ])</p><p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生 出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包 中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化 为一个只和前i−1件物品相关的问题。如果不放第i件物品，那么问题就转化 为“前i−1件物品放入容量为v的背包中”，价值为F[i−1,v]；如果放第i件物 品，那么问题就转化为“前i−1件物品放入剩下的容量为v −Wi的背包中”， 此时能获得的最大价值就是F[i−1,v −Wi]再加上通过放入第i件物品获得的价 值Ci。——《背包九讲》</p><pre><code class="lang-cpp">//code by extmool#include &lt;iostream&gt;#define V 500   //可以用 const int V=500 来代替using namespace std;int weight[20 + 1];int value[20 + 1];int f[20 + 1][V + 1];int main() {    int n, m;    cout &lt;&lt; &quot;请输入物品个数:&quot;;    cin &gt;&gt; n;    cout &lt;&lt; &quot;请分别输入&quot; &lt;&lt; n &lt;&lt; &quot;个物品的重量和价值:&quot; &lt;&lt; endl;     for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; weight[i] &gt;&gt; value[i];    }    cout &lt;&lt; &quot;请输入背包容量:&quot;;    cin &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m; j++) {            if (weight[i] &gt; j) {                f[i][j] = f[i - 1][j];            }            else {                f[i][j] = f[i - 1][j] &gt; f[i - 1][j - weight[i]] + value[i] ? f[i - 1][j] : f[i - 1][j - weight[i]] + value[i];            }        }    }        cout &lt;&lt; &quot;背包能放的最大价值为:&quot; &lt;&lt; f[n][m] &lt;&lt; endl; //输出最大价值}</code></pre><h3 id="空间优化（重点）"><a href="#空间优化（重点）" class="headerlink" title="空间优化（重点）"></a>空间优化（重点）</h3><p>我们压缩一下数组，方程就变成了这样</p><p>F[v]=max⁡(F[v],F[v - W[ⅈ]] + C[ⅈ])</p><p>但是第二重循环要逆序</p><p>为什么可以逆序？<br>因为我们如果正序循环修改了1个数的话，后面可能会用该数进行2次辨断，这样可能会多选几次。</p><blockquote><p>懒得敲代码了</p></blockquote><pre><code class="lang-cpp">//code by extmool#include &lt;iostream&gt;#define V 500using namespace std;int weight[20 + 1];int value[20 + 1];int f[V + 1];int main() {    int n, m;    cout &lt;&lt; &quot;请输入物品个数:&quot;;    cin &gt;&gt; n;    cout &lt;&lt; &quot;请分别输入&quot; &lt;&lt; n &lt;&lt; &quot;个物品的重量和价值:&quot; &lt;&lt; endl;     for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; weight[i] &gt;&gt; value[i];    }    cout &lt;&lt; &quot;请输入背包容量:&quot;;    cin &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        for (int j = m; j &gt;= 1; j--) {            if (weight[i] &lt;= j) {                f[j] = f[j] &gt; f[j - weight[i]] + value[i] ? f[j] : f[j - weight[i]] + value[i];            }        }    }    cout &lt;&lt; &quot;背包能放的最大价值为:&quot; &lt;&lt; f[m] &lt;&lt; endl;}</code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>时间仓促，如有ｂｕｇ请大佬指出，Ｔｈａｎｋｓ <del>%%%</del></p><p>至于正序会怎么样？　秒变完全背包</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分</title>
      <link href="//articles/2018/12/%E5%B7%AE%E5%88%86/"/>
      <url>//articles/2018/12/%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p><del>坑不只占了一年么</del></p><p>感谢Herself32推荐的模板题</p></blockquote><p>差分以前缀和为基础（前缀差？），可以实现O(1)修改，O(n)查询。<br><a id="more"></a> </p><h3 id="例题-洛谷P2367-语文成绩"><a href="#例题-洛谷P2367-语文成绩" class="headerlink" title="例题 洛谷P2367 语文成绩"></a>例题 <a href="https://www.luogu.org/problemnew/show/P2367" target="_blank" rel="noopener">洛谷P2367 语文成绩</a></h3><h4 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h4><p>语文考试结束了，成绩还是一如既往地有问题。</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？</p><p>//这又跟神器有什么关系呢？神说：呵呵。</p><p>//因为n和p的范围比较大 建议C++选手使用scanf读入.</p><p>//同时建议写读入优化….</p><p>//最后一个点，亲测pas读入800+ms，c/C++的scanf 1200+ms，所以这个点的时限改为2s</p><h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h5><p>第一行有两个整数n，p，代表学生数与增加分数的次数。</p><p>第二行有n个数，a1~an，代表各个学生的初始成绩。</p><p>接下来p行，每行有三个数，x，y，z，代表给第x个到第y个学生每人增加z分。</p><h5 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h5><p>输出仅一行，代表更改分数后，全班的最低分。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><h5 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h5><pre><code>3 21 1 11 2 12 3 1</code></pre><h5 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h5><pre><code>2</code></pre><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>对于40%的数据，有n&lt;=1000</p><p>对于60%的数据，有n&lt;=10000</p><p>对于80%的数据，有n&lt;=100000</p><p>对于100%的数据，有n&lt;=5000000，p&lt;=n，学生初始成绩&lt;=100，z&lt;=100</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>cin + 差分</p><h3 id="什么是差分"><a href="#什么是差分" class="headerlink" title="什么是差分"></a>什么是差分</h3><p>我们有两个数组a[5] = {1,3,5,2,4};，A[5]。</p><p>我们让A存储a数组中，每相邻两个数的差。即A[i] = a[i] - a[i - 1]</p><p>于是 两个数组对应如下</p><div class="table-container"><table><thead><tr><th>数组</th><th>column1</th><th>column2</th><th>column3</th><th>column4</th><th>column5</th></tr></thead><tbody><tr><td>a</td><td>1</td><td>3</td><td>5</td><td>2</td><td>4</td></tr><tr><td>A</td><td>1</td><td>2</td><td>2</td><td>-3</td><td>2</td></tr></tbody></table></div><p>把a[2]到a[4]都加5，再预处理A[i] = a[i] - a[i - 1]</p><p>于是 两个数组对应如下</p><div class="table-container"><table><thead><tr><th>数组</th><th>column1</th><th>column2</th><th>column3</th><th>column4</th><th>column5</th></tr></thead><tbody><tr><td>a</td><td>1</td><td>8</td><td>10</td><td>7</td><td>4</td></tr><tr><td>A</td><td>1</td><td>7</td><td>2</td><td>-3</td><td>-3</td></tr></tbody></table></div><p>我们发现A数组中只有A[2]和A[4+1]的数变化。（等式的性质）</p><p>想想为什么吧</p><p>于是，我们反推，只O(1)修改A数组的两个值，之后便可O(n)咨询出a数组的值。</p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><pre><code class="lang-cpp">A[l] += k;A[r + 1] -= k;</code></pre><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code class="lang-cpp">for (int i = 1; i &lt;= n; i++){    a[i] = a[i - 1] + A[i];    cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;}</code></pre><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;int a[1000], A[1000];int n;int main(){    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)    {        cin &gt;&gt; a[i];        A[i] = a[i] - a[i - 1];    }    char cmd;    while (true)    {        cin &gt;&gt; cmd;        switch (cmd)        {        case &#39;p&#39;:            int l, r, k;            cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;            A[l] += k;            A[r + 1] -= k;            break;        case &#39;v&#39;:            for (int i = 1; i &lt;= n; i++)            {                a[i] = a[i - 1] + A[i];                cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;            }            cout &lt;&lt; endl;            break;        case &#39;s&#39;:            return 0;        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="//articles/2018/12/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>//articles/2018/12/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>前缀和是一种重要的思想</p><a id="more"></a> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好吧，本文用它来处理区间，先说说它的复杂度，它可以在O(n)的预处理后实现O(1)的区间查询，而线段树的时间复杂度为O(logN)。</p><h2 id="一道水题。。。"><a href="#一道水题。。。" class="headerlink" title="一道水题。。。"></a>一道水题。。。</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>给你n个数和m次查询，每次查询要求你输出1～x的和。</p><h3 id="输出输入格式"><a href="#输出输入格式" class="headerlink" title="输出输入格式"></a>输出输入格式</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行 n，m</p><p>第二行n个数a[]</p><p>接下来m行每行输入一个x代表1～x </p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对于每次查询，输出1～x的每个数的和</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><pre><code>5 21 3 5 2 434</code></pre><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><pre><code>911</code></pre><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>大家展开了一场激烈的讨论。</p><blockquote><ul><li><p>lz： 一个一个加</p></li><li><p>MoveToEx： 线段树 ！</p></li><li><p>太阳 : 这不前缀和板子题么</p></li></ul></blockquote><p>我们开一个数组sum[]</p><p>接下来O(n)预处理</p><p>令sum[i] += a[i] + sum[i-1]</p><p>于是 两个数组对应如下</p><div class="table-container"><table><thead><tr><th>数组</th><th>column1</th><th>column2</th><th>column3</th><th>column4</th><th>column5</th></tr></thead><tbody><tr><td>a</td><td>1</td><td>3</td><td>5</td><td>2</td><td>4</td></tr><tr><td>sum</td><td>1</td><td>4</td><td>9</td><td>11</td><td>15</td></tr></tbody></table></div><p>发现，sum[i]存储了a[1～i]元素的和。</p><p>接下来O(1)输出就行了。</p><h2 id="升级版"><a href="#升级版" class="headerlink" title="升级版"></a>升级版</h2><p>如果我们查询a[x～y]的和呢。</p><p>如果您问小学生，他们会毫不犹豫地回答：</p><p>“拿sum[y]-sum[x-1]就可以了~~~,这不小学数学减法题吗！？？”</p><p><del>…被小学生吊打</del></p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><pre><code class="lang-cpp">void setup(){    for(int i-1;i&lt;=n;i++)        sum[i] = sum[i-1] + a[i];}int query(int l, int r) //查询{    return sum(r) - sum(l-1);}</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>有人问了，那修改怎么办呢，下一篇博文我会<del>江</del>的。。</p><p>“差分“</p>]]></content>
      
      
      
        <tags>
            
            <tag> 区间 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++各个函数读写速度一览</title>
      <link href="//articles/2018/10/C-%E5%90%84%E4%B8%AA%E5%87%BD%E6%95%B0%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6%E4%B8%80%E8%A7%88/"/>
      <url>//articles/2018/10/C-%E5%90%84%E4%B8%AA%E5%87%BD%E6%95%B0%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6%E4%B8%80%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>cin函数测试有问题！！！仅供参考！！！<br><a id="more"></a> </p><h3 id="有bug-各个函数的读入速度"><a href="#有bug-各个函数的读入速度" class="headerlink" title="(有bug)各个函数的读入速度"></a>(有bug)各个函数的读入速度</h3><blockquote><p>整数和字符</p><p>cpu:i7-7700HQ g++ 6.3.0</p></blockquote><div class="table-container"><table><thead><tr><th>名称</th><th>10^5整数</th><th>10^6整数</th><th>10^7整数</th><th>10M字符串</th></tr></thead><tbody><tr><td>fin</td><td>66毫秒</td><td>692毫秒</td><td>6831毫秒</td><td>117毫秒</td></tr><tr><td>cin</td><td>108毫秒</td><td>45毫秒</td><td>425毫秒</td><td>1毫秒</td></tr><tr><td>cin关同步</td><td>76毫秒</td><td>40毫秒</td><td>397毫秒</td><td>77毫秒</td></tr><tr><td>scanf</td><td>29毫秒</td><td>287毫秒</td><td>2838毫秒</td><td>75毫秒</td></tr><tr><td>FILE* fscanf</td><td>29毫秒</td><td>280毫秒</td><td>2818毫秒</td><td>68毫秒</td></tr><tr><td>快读</td><td>4毫秒</td><td>44毫秒</td><td>463毫秒</td></tr></tbody></table></div><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;using namespace std;char s[10000005];int x[10000005];void tfst(string name, int n){    ifstream fin(name.c_str());    for (int i = 0; i &lt;= n; i++)        fin &gt;&gt; x[i];    fin.close();}void tfsts(string name){    ifstream fin(name.c_str());    fin &gt;&gt; s;    fin.close();}void tfreSan(string name, int n){    freopen(name.c_str(), &quot;r&quot;, stdin);    for (int i = 0; i &lt;= n; i++)        scanf(&quot;%d&quot;, &amp;x[i]);    fclose(stdin);}void tfresSan(string name){    freopen(name.c_str(), &quot;r&quot;, stdin);    scanf(&quot;%s&quot;, s);    fclose(stdin);}void tfreFSan(string name, int n){    FILE *fin;    fin = fopen(name.c_str(), &quot;r&quot;);    for (int i = 0; i &lt;= n; i++)        fscanf(fin, &quot;%d&quot;, &amp;x[i]);    fclose(fin);}void tfresFSan(string name){    FILE *fin;    fin = fopen(name.c_str(), &quot;r&quot;);    fscanf(fin, &quot;%s&quot;, s);    fclose(fin);}void tfreCin(string name, int n){    freopen(name.c_str(), &quot;r&quot;, stdin);    for (int i = 0; i &lt;= n; i++)        cin &gt;&gt; x[i];    fclose(stdin);}void tfresCin(string name){    freopen(name.c_str(), &quot;r&quot;, stdin);    cin &gt;&gt; s;    fclose(stdin);}void tfreCinS(string name, int n){    freopen(name.c_str(), &quot;r&quot;, stdin);    std::ios::sync_with_stdio(false);    for (int i = 0; i &lt;= n; i++)        cin &gt;&gt; x[i];    std::ios::sync_with_stdio(true);    fclose(stdin);}void tfresCinS(string name){    freopen(name.c_str(), &quot;r&quot;, stdin);    std::ios::sync_with_stdio(false);    scanf(&quot;%s&quot;, s);    std::ios::sync_with_stdio(true);    fclose(stdin);}inline int qr(){    int data = 0, k = 1;    char c;    for (c = getchar(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c == &#39;-&#39;; c = getchar())        if (c == &#39;-&#39;)            k = -1;    for (; &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;; c = getchar())        data = data * 10 + c - &#39;0&#39;;    return data * k;}void makeInt(string name, int n){    ofstream fout(name.c_str());    for (int i = 1; i &lt;= n; i++)        fout &lt;&lt; rand() &lt;&lt; &quot; &quot;;    fout.close();}void tq(string name, int n){    freopen(name.c_str(), &quot;r&quot;, stdin);    for (int i = 0; i &lt;= n; i++)        x[i] = qr();    fclose(stdin);}void makeChar(string name){    freopen(name.c_str(), &quot;w&quot;, stdout);    for (int i = 1; i &lt;= 10000000; i++)        putchar(&#39;%&#39;);    fclose(stdout);}int main(){    srand(time(0));    int st, et;    makeInt(&quot;d1.in&quot;, 100000);    makeInt(&quot;d2.in&quot;, 1000000);    makeInt(&quot;d3.in&quot;, 10000000);    makeChar(&quot;d4.in&quot;);    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);    st = clock();    tfst(&quot;d1.in&quot;, 100000);    et = clock();    cout &lt;&lt; &quot;fin 10^5耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfst(&quot;d2.in&quot;, 1000000);    et = clock();    cout &lt;&lt; &quot;fin 10^6耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfst(&quot;d3.in&quot;, 10000000);    et = clock();    cout &lt;&lt; &quot;fin 10^7耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfsts(&quot;d4.in&quot;);    et = clock();    cout &lt;&lt; &quot;fin 10M耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreCin(&quot;d1.in&quot;, 100000);    et = clock();    cout &lt;&lt; &quot;cin 10^5耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreCin(&quot;d2.in&quot;, 1000000);    et = clock();    cout &lt;&lt; &quot;cin 10^6耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreCin(&quot;d3.in&quot;, 10000000);    et = clock();    cout &lt;&lt; &quot;cin 10^7耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfresCin(&quot;d4.in&quot;);    et = clock();    cout &lt;&lt; &quot;cin 10M耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreCinS(&quot;d1.in&quot;, 100000);    et = clock();    cout &lt;&lt; &quot;cin sync_with_stdio(false) 10^5耗时&quot; &lt;&lt; (double) (et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreCinS(&quot;d2.in&quot;, 1000000);    et = clock();    cout &lt;&lt; &quot;cin sync_with_stdio(false) 10^6耗时&quot; &lt;&lt; (double) (et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreCinS(&quot;d3.in&quot;, 10000000);    et = clock();    cout &lt;&lt; &quot;cin sync_with_stdio(false) 10^7耗时&quot; &lt;&lt; (double) (et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfresCinS(&quot;d4.in&quot;);    et = clock();    cout &lt;&lt; &quot;cin sync_with_stdio(false) 10M耗时&quot; &lt;&lt; (double) (et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreSan(&quot;d1.in&quot;, 100000);    et = clock();    cout &lt;&lt; &quot;scanf 10^5耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreSan(&quot;d2.in&quot;, 1000000);    et = clock();    cout &lt;&lt; &quot;scanf 10^6耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreSan(&quot;d3.in&quot;, 10000000);    et = clock();    cout &lt;&lt; &quot;scanf 10^7耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfresSan(&quot;d4.in&quot;);    et = clock();    cout &lt;&lt; &quot;scanf 10M耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreFSan(&quot;d1.in&quot;, 100000);    et = clock();    cout &lt;&lt; &quot;FILE* fscanf 10^5耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreFSan(&quot;d2.in&quot;, 1000000);    et = clock();    cout &lt;&lt; &quot;FILE* fscanf 10^6耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfreFSan(&quot;d3.in&quot;, 10000000);    et = clock();    cout &lt;&lt; &quot;FILE* fscanf 10^7耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tfresFSan(&quot;d4.in&quot;);    et = clock();    cout &lt;&lt; &quot;FILE* fscanf 10M耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tq(&quot;d1.in&quot;, 100000);    et = clock();    cout &lt;&lt; &quot;快读 10^5耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tq(&quot;d2.in&quot;, 1000000);    et = clock();    cout &lt;&lt; &quot;快读 10^6耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    st = clock();    tq(&quot;d3.in&quot;, 10000000);    et = clock();    cout &lt;&lt; &quot;快读 10^7耗时&quot; &lt;&lt; (double)(et - st) / CLOCKS_PER_SEC * 1000 &lt;&lt; &quot;毫秒&quot; &lt;&lt; endl;    return 0;}</code></pre><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>其他人测的结果：“cin总是最慢的，cin关同步和scanf差不多”。</p><p>总之。。。</p><p>快读大fa好orz。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 卡常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快读&amp;&amp;快写——模板与解释</title>
      <link href="//articles/2018/10/%E5%BF%AB%E8%AF%BB&amp;&amp;%E5%BF%AB%E5%86%99%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E4%B8%8E%E8%A7%A3%E9%87%8A/"/>
      <url>//articles/2018/10/%E5%BF%AB%E8%AF%BB&amp;&amp;%E5%BF%AB%E5%86%99%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E4%B8%8E%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>（int）<br>本文将教你如何自制读入，写入函数(不常用)</p><p>不保证在一些玄学情况下变快<br><a id="more"></a> </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当初liuzhe在昌邑一中时，day1 T1数据非常大（机房电脑也特别慢），导致在本地测试大样例scanf过不去（不过评测机可以过），于是在此介绍一下快读&amp;&amp;快写。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>有没有发现putchar()、getchar()特别快，快读&amp;&amp;快写就是用他们读入（写入相反）char字符后转为int类型的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="模板-amp-amp-解释释"><a href="#模板-amp-amp-解释释" class="headerlink" title="模板&amp;&amp;解释释"></a>模板&amp;&amp;解释释</h3><pre><code class="lang-cpp">inline int qr(){    int data = 0, k = 1;    //data存放转换后的数据，k存正负数    char c;    for (c = getchar(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c == &#39;-&#39;; c = getchar())    //过滤无用字符        if (c == &#39;-&#39;)            k = -1;    for (; &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;; c = getchar())        data = data * 10 + c - &#39;0&#39;;     //char转int后存入data    return data * k;        //返回 (±)data}inline void qw(int x)       //这个估计能看懂，不打注释了{    if (x&lt;0)    {        putchar(&#39;-&#39;);        x=-x;    }    if(x&gt;9) qw(x/10);    putchar(x%10+&#39;0&#39;);}</code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li><p>莴据MoveToEx神犇的博文来看，for改为while更快</p></li><li><p>快读可以用fread优化。</p></li></ol><p>[shq‘s-blog]  <a href="https://blog.ishq.site/articles/OI%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96-%E8%BF%9B%E9%98%B6/" target="_blank" rel="noopener">https://blog.ishq.site/articles/OI%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96-%E8%BF%9B%E9%98%B6/</a></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>[A+B Problem] <a href="https://www.luogu.org/problemnew/show/P1001" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P1001</a></p><p>[排队接水] <a href="https://www.luogu.org/problemnew/show/P1223" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P1223</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 卡常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra从入门到出门</title>
      <link href="//articles/2018/09/Dijkstra%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%87%BA%E9%97%A8/"/>
      <url>//articles/2018/09/Dijkstra%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%87%BA%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Dijkstra算法是一种求最短路的算法。</p><p>朴素的Dijkstra时间复杂度 O(n²)</p><h2 id="此算法不适用于-边权为负-的图"><a href="#此算法不适用于-边权为负-的图" class="headerlink" title="此算法不适用于 边权为负 的图"></a>此算法不适用于 边权为负 的图</h2></blockquote><a id="more"></a> <p><br></p><h2 id="不啰嗦了，开门见山"><a href="#不啰嗦了，开门见山" class="headerlink" title="不啰嗦了，开门见山"></a>不啰嗦了，开门见<del>山</del></h2><p><img src="/09/Dijkstra从入门到出门/mar.png" alt="mar"> <del>我在后门看你十分钟了！！！</del></p><p>dijkstra可以求两点间的最短路径，这种也叫单源最短路。</p><p>而Floyd求的是多个点之间的最短路。</p><p>dijkstra有很多奇奇怪怪的优化，我们后面用STL优先级队列（priority_queue）把dijkstra优化到O(nlogn)</p><h2 id="朴素的Dijkstra"><a href="#朴素的Dijkstra" class="headerlink" title="朴素的Dijkstra"></a>朴素的Dijkstra</h2><h3 id="思想-amp-amp-实现"><a href="#思想-amp-amp-实现" class="headerlink" title="思想&amp;&amp;实现"></a>思想&amp;&amp;实现</h3><p>dijkstra的思想大体是这样： 找与当前点距离最小的点，同时用它来更新与他相邻的其它点。</p><p>我们，有一张无向图。</p><p>求2到4的最短路径。</p><p><img src="/09/Dijkstra从入门到出门/graph.png" alt></p><p>我们开一个dis数组和vis数组，dis[i]=j表示起点到i号点的距离为j，vis[i]表示i号结点有没有被遍历过。</p><p>初始化：</p><pre><code class="lang-cpp">for (int i = 1; i &lt;= n; i++)    for (int j = 1; j &lt;= n; j++)        e[i][j] = 99999999;</code></pre><p>先把dis[i]设为原点到点i的距离，这样才方便求min～～</p><pre><code class="lang-cpp">for (int i = 1; i &lt;= n; i++)    dis[i] = e[1][i];</code></pre><p>我们先从2号点开始遍历，我们把vis[2]设为true，把dis[2]设为0（因为2是原点）。</p><pre><code class="lang-cpp">vis[start] = true;dis[start] = 0;</code></pre><p><img src="/09/Dijkstra从入门到出门/graph1.png" alt></p><blockquote><p>这是原点，所以不需要其他操作（更新最短路）</p></blockquote><p>我们枚举2号结点的临边</p><p>我们的循环首先找到了5,5没有被遍历.</p><p>我们用5推出其他节点的路径：dis[6] &lt; dis[5]+27=29,发现比他长，不改. dis[1]=dis[5]+8=10,</p><p><img src="/09/Dijkstra从入门到出门/graph2.png" alt></p><p>Dijkstra的形式类似于广搜，而不是深搜</p><p>我们接着寻找2号结点的其他临边，找到了点6，vis[6]=true.</p><p><img src="/09/Dijkstra从入门到出门/graph3.png" alt></p><p>用6更新5号，1号点，发现比他们大，不更新。</p><pre><code class="lang-cpp">for (int i = 1; i &lt;= n; i++){        u = 0;    min = 99999999;    for (int j = 1; j &lt;= n; j++)        if (vis[j] == false &amp;&amp; min &gt; dis[j])        {            dis[j] = min;            u = j;        }    if (u)    {        vis[u] = true;        for (int v = 1; v &lt;= n; v++)            if (dis[v] &gt; dis[u] + e[u][v])                dis[v] = dis[u] + e[u][v];    }}</code></pre><p>至此，2到每个点的路经为：</p><p>dis[] = {10, 0, 9999999, 9999999, 2, 5}</p><p> 后面的处理相信你也会了，本弱不多说了。。。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;int m, n, e[10000][10000], dis[10000], a, b, q, start, u;bool vis[10000] = {};int main(){    cin &gt;&gt; n &gt;&gt; m;    cin &gt;&gt; start;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= n; j++)            e[i][j] = 99999999;    for (int i = 1; i &lt;= m; i++)    {        cin &gt;&gt; a &gt;&gt; b &gt;&gt; q;        e[a][b] = q;        e[b][a] = q;        e[a][a] = 0;        e[b][b] = 0;    }    for (int i = 1; i &lt;= n; i++)        dis[i] = e[start][i];    /*----------核心代码----------*/    dis[start] = 0;    vis[start] = true;    for (int i = 1; i &lt;= n; i++)    {        u = 0;        int Min = 99999999;        for (int j = 1; j &lt;= n; j++)            if (vis[j] == false &amp;&amp; Min &gt; dis[j])            {                Min = dis[j];                u = j;            }        if (u)        {            vis[u] = true;            for (int v = 1; v &lt;= n; v++)                if (dis[v] &gt; dis[u] + e[u][v])                    dis[v] = dis[u] + e[u][v];        }    }    /*-----------------------------*/    for (int i = 1; i &lt;= n; i++)        cout &lt;&lt; dis[i] &lt;&lt; &quot; &quot;;    return 0;}</code></pre><h2 id="STL堆（优先级队列）优化的Dijkstra"><a href="#STL堆（优先级队列）优化的Dijkstra" class="headerlink" title="STL堆（优先级队列）优化的Dijkstra"></a>STL堆（优先级队列）优化的Dijkstra</h2><h3 id="对之前的思考"><a href="#对之前的思考" class="headerlink" title="对之前的思考"></a>对之前的思考</h3><p>我们在找最短路时，有这么一段代码：</p><pre><code class="lang-cpp">for (int j = 1; j &lt;= n; j++)    if (vis[j] == false &amp;&amp; Min &gt; dis[j])    {        Min = dis[j];        u = j;    }</code></pre><p>这段代码可以优化</p><p>它的作用是找一个与当前节点距离最小的点，我们用的是的是顺序查找，复杂度为O(n),而我们学过的堆正好可以找最小值，时间复杂度为O(logn),再乘上我们的另一个n，于是复杂度变为O(nlogn)。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="lang-cpp">#include &lt;cstdio&gt;#include &lt;queue&gt;#define maxn 1000000using namespace std;/*----------邻接表----------*/int head[maxn], num = 0;struct node{    int data;    int to;    int next;} edge[maxn];inline void add_edge(int from, int to, int data){    edge[++num].next = head[from];    head[from] = num;    edge[num].data = data;    edge[num].to = to;}/*----------优先级队列----------*/struct Heap            //小根堆{    int d, e;            //到e权值为d    bool operator&lt;(const Heap &amp;b) const  //运算符重载    {        return d &gt; b.d;    }};priority_queue&lt;Heap&gt; q;/*----------Dijkstra----------*/int n, m, dis[maxn] = {}, start;bool vis[maxn] = {};inline void Dijkstra(int start){    Heap x;    q.push((Heap) {0, start});        //定义临时对象    dis[start] = 0;    while (!q.empty())    {        x = q.top();        //找一个与当前节点距离最小的点        q.pop();        int e = x.e;        if (vis[e])                continue;        vis[e] = true;        for (int i = head[e]; i; i = edge[i].next)        //用找到的点更新最短路并加入堆        {            dis[edge[i].to] = min(dis[edge[i].to], dis[e] + edge[i].data);                q.push((Heap){dis[edge[i].to], edge[i].to});        }    }}/*----------主函数----------*/int main(int argc, char **argv){    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;start);    for (int i = 1; i &lt;= m; i++)    {        int q, w, e;        scanf(&quot;%d%d%d&quot;, &amp;q, &amp;w, &amp;e);        add_edge(q, w, e);    }    for (int i = 1; i &lt;= n; i++)        //初始化        dis[i] = 2147483647;    Dijkstra(start);    for (int i = 1; i &lt;= n; i++)        printf(&quot;%d &quot;, dis[i]);    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给你的程序提速:论C++中的那些坑</title>
      <link href="//articles/2018/08/%E7%BB%99%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%8F%90%E9%80%9F-%E8%AE%BAC++%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
      <url>//articles/2018/08/%E7%BB%99%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%8F%90%E9%80%9F-%E8%AE%BAC++%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>dalao勿喷,本文将给你的程序提速，避免踩坑。<br><a id="more"></a> </p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发一个小项目时，我有一个程序一直编译过不了，后来才发现和std里有一个函数冲突了。。QAQ，于是“感慨万千”写下此文。</p><h2 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑"></a>常见的坑</h2><h3 id="namespace的坑"><a href="#namespace的坑" class="headerlink" title="namespace的坑"></a>namespace的坑</h3><blockquote><p>不要把bits/stdc++.h和using namespace std一块用</p></blockquote><p>bit/stdc++.h 是万能头</p><p>using namespace std 是取消所有的std名称空间</p><blockquote><p>std::cout -&gt; cout</p></blockquote><p>因为假设你写了一个函数和和std里的刚好冲突。。。。</p><h3 id="for的坑"><a href="#for的坑" class="headerlink" title="for的坑"></a>for的坑</h3><p>我们来看一段代码</p><pre><code class="lang-cpp">int n;scanf(&quot;%d&quot;, &amp;n);for(int i=1 ; i &lt;= n/2 ; i++){    //code}</code></pre><p>这段代码看上去无任何问题,它循环了n/2次，但它实际上同时计算了n遍n/2，数据大的话可能会TLE的。</p><p>我们不如这样写：</p><pre><code class="lang-cpp">int n;scanf(&quot;%d&quot;, &amp;n);for(int i=1,N=n/2 ; i &lt;= N ; i++){    //code}</code></pre><p>或</p><pre><code class="lang-cpp">int n;scanf(&quot;%d&quot;, &amp;n);int N=n/2;for(int i=1; i &lt;= N ; i++){    //code}</code></pre><p>这样就能快好多了。</p><h3 id="STL-“-gt-gt-”的坑"><a href="#STL-“-gt-gt-”的坑" class="headerlink" title="STL “&gt; &gt;”的坑"></a>STL “&gt; &gt;”的坑</h3><p>我们定一个小根堆</p><pre><code class="lang-cpp">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q;</code></pre><p>编译报错</p><pre><code class="lang-bash"> error: ‘&gt;&gt;’ should be ‘&gt; &gt;’ within a nested template argument list priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q;</code></pre><blockquote><p>错误：“嵌套模板参数列表”中的“&gt;&gt;”应该是“&gt; &gt;”</p></blockquote><p>正确定义：</p><pre><code class="lang-cpp">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;</code></pre><h3 id="多测一定要清空"><a href="#多测一定要清空" class="headerlink" title="多测一定要清空"></a>多测一定要清空</h3><h3 id="一定不要忘初始化并查集"><a href="#一定不要忘初始化并查集" class="headerlink" title="一定不要忘初始化并查集"></a>一定不要忘初始化并查集</h3><h2 id="运算符的优化"><a href="#运算符的优化" class="headerlink" title="运算符的优化"></a>运算符的优化</h2><h3 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h3><p>“^”(异或运算符，位值相同为0，不同为1)</p><pre><code class="lang-cpp">int x=2,y=1;x ^= y;y ^= x;x ^= y;cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y;</code></pre><p>运行结果</p><pre><code class="lang-bash">1 2</code></pre><h3 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h3><p>”&amp;“(按位与运算符，位值都为1为1，不为1时为0)</p><pre><code class="lang-cpp">if(i&amp;1)    cout&lt;&lt;i&lt;&lt;&quot;是奇数&quot;&lt;&lt;endl;else    cout&lt;&lt;i&lt;&lt;&quot;是偶数&quot;&lt;&lt;endl;</code></pre><blockquote><p>例如一个数 N,(N&amp;1)的结果就是取二进制的最末位。<br>这可以用来判断一个整数的奇偶，<br>二进制的最末位为0表示该数为偶数，<br>最末位为1表示该数为奇数.<br>这是因为二进制数末位的权值为2的0次方等于1,<br>其他位置上则为2的非0整数次方,使其权值不会产生奇数</p></blockquote><h3 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h3><p>“&lt;&lt;”(左移运算符，把该数的二进制位左移n位)</p><p>下面的语句是等价的</p><p>n * 2</p><p>n &lt;&lt; 1</p><blockquote><p>左移一位相当于乘2</p></blockquote><h3 id="除"><a href="#除" class="headerlink" title="除"></a>除</h3><p>“&gt;&gt;”(右移运算符，把该数的二进制位右移n位)</p><p>下面的语句是等价的</p><p>n / 2</p><p>n &gt;&gt; 1</p><blockquote><p>右移一位相当于除以2</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于优化的就讲这么多了，有兴趣的童靴可以对二进制位做深入的研究，这里就不再多说了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 卡常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的邻接表存储</title>
      <link href="//articles/2018/08/%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8/"/>
      <url>//articles/2018/08/%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="邻接表作用"><a href="#邻接表作用" class="headerlink" title="邻接表作用"></a>邻接表作用</h3><blockquote><p>为神魔药学图的邻接表存储呢？邻接矩阵多好！</p></blockquote><p>有时，当图很稀疏时，用邻接矩阵就会产生不必要的内存浪费。<br><a id="more"></a><br>如下图：</p><p><img src="/08/图的邻接表存储/graph.png" alt="1"></p><p>它的邻接矩阵大概是这样：</p><p>0 5 ∞ ∞ ∞</p><p>5 0 3 ∞ ∞</p><p>∞ 3 0 1 ∞</p><p>∞ ∞ 1 0 3</p><p>∞ ∞ ∞ 3 0</p><p>我们发现，这样的图用邻接表存储很浪费时空。这样的图我们可以用邻接表来存。</p><h3 id="邻接表原理"><a href="#邻接表原理" class="headerlink" title="邻接表原理"></a>邻接表原理</h3><p>邻接矩阵表示的是点与点的关系，而邻接表表示的是边和点的关系。</p><p>我们有一个数组，head[i]，存的是i点发出的第一条边编号。</p><p>同时，每一条边还有next,to,data变量，用来存储这条边的一个兄弟边的编号，即存储这条边的一个相邻的边的编号,to代表这条边到哪，data代表边权。</p><p><img src="/08/图的邻接表存储/1.png" alt="1"></p><p>首先，我们添加从 1-&gt;2 的边，当前边的编号为1，把head[1]发出的第一条边的编号设为1（这里1-&gt;2边的编号是1，所以是1）。</p><p>因为是无向图，所以我们也要添加一条从 2-&gt;1的边，这条边的编号为2，我们把把head[2]发出的第一条边的编号设为2。</p><p><img src="/08/图的邻接表存储/2.png" alt="2"></p><p>我们添加从 2-&gt;3 的边，当前边的编号为3，把head[2]发出的第一条边的编号设为3，把原先的head[2]=2设为3的next。</p><p>我们也添加一条从 3-&gt;2的边，这条边的编号为4，我们把把head[3]发出的第一条边的编号设为4。</p><p><img src="/08/图的邻接表存储/3.png" alt="3"></p><p>我们添加从 3-&gt;4 的边，当前边的编号为5，把head[3]发出的第一条边的编号设为5，把原先的head[3]=4设为5的next。</p><p>我们也添加一条从 4-&gt;3的边，这条边的编号为6，我们把把head[4]发出的第一条边的编号设为6。</p><p><img src="/08/图的邻接表存储/4.png" alt="4"></p><p>我们添加从 4-&gt;5 的边，当前边的编号为7，把head[4]发出的第一条边的编号设为6，把原先的head[4]=6设为7的next。</p><p>我们也添加一条从 5-&gt;4的边，这条边的编号为8，我们把把head[5]发出的第一条边的编号设为8。</p><p><img src="/08/图的邻接表存储/5.png" alt="5"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="lang-cpp">const int maxn=1000;struct node{    int to;    int data;    int next;}edge[maxn];int head[maxn],num=0;void add_edge(int from,int to,int data){    num++;    edge[num].next = head[from];    head[from] = num;    edge[num].to = to;    edge[num].data = data;}add_edge(1,2,5);    //有向图add_edge(1,2,5);add_edge(2,1,5);    //无向图</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路Floyd</title>
      <link href="//articles/2018/08/%E6%9C%80%E7%9F%AD%E8%B7%AFFloyd/"/>
      <url>//articles/2018/08/%E6%9C%80%E7%9F%AD%E8%B7%AFFloyd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最短路算法指的是求点和点之间边权最小的路径的算法。<br><a id="more"></a> </p></blockquote><h3 id="神魔是最短路？"><a href="#神魔是最短路？" class="headerlink" title="神魔是最短路？"></a>神魔是最短路？</h3><p>最短路算法指的是求点和点之间边权最小的路径的算法。</p><p>如下图：</p><p>1 —&gt; 3的最短路是 1-&gt;4-&gt;0-&gt;2-&gt;3</p><p>而最短路算法可以快速的帮我们解决此类问题。</p><p><img src="/08/最短路Floyd/graph.png" alt="graph"></p><p>以下是NOIP必学的最短路算法</p><blockquote><p>Floyd O(n³) 多源最短路</p><p>Dijkstra O(n²) 单源最短路</p><p>SPFA O(nm) 单源最短路</p><h3 id="Floyd求最短路过程"><a href="#Floyd求最短路过程" class="headerlink" title="Floyd求最短路过程"></a>Floyd求最短路过程</h3></blockquote><p>还拿上图举例（懒得画了 qwq）</p><p><img src="/08/最短路Floyd/graph.png" alt="graph"></p><p>Floyd可以求任意两点间的最短路径</p><p>Floyd基于类似三角不等式的思想，用了动态规划的思想。它在求两个点a.b的最短路时，在点外再找一个点k，看ak + bk是否小于ab。如果是，就更新ab为ak+bk。</p><p><img src="/08/最短路Floyd/graph1.png" alt="graph1"></p><p>如上图，5-0可以找到4来更新，5-&gt;4=2,4-&gt;0=4,2+4=6 &gt; 7</p><p>于是5-0被更新成6</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>核心代码：</p><pre><code class="lang-cpp">void floyd()        //很简单，核心代码只有五行{    for(int k=1;k&lt;=n;k++)        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)                if(a[i][j] &gt; a[i][k]+a[k][j])                    a[i][j] = a[i][k]+a[k][j];}</code></pre><p>程序：</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#define maxn 10005#define inf 9999999using std::cin;using std::cout;int a[maxn][maxn]={},x,y,w,m,n;void floyd()        //很简单，核心代码只有五行{    for(int k=1;k&lt;=n;k++)        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;=n;j++)                if(a[i][j] &gt; a[i][k]+a[k][j])                    a[i][j] = a[i][k]+a[k][j];}int main(){    cin&gt;&gt;n&gt;&gt;m;      // n个点,m条边    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)        {            if(i==j) a[i][j]=0;            else a[i][j] = inf;   //初始化，用9999999表示不相连        }    for(int i=1;i&lt;=m;i++)    {        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;        a[x][y] = w;    }    floyd();    for(int i=1;i&lt;=n;i++)       //输出    {        for(int j=1;j&lt;=n;j++)        {            if(a[i][j] != inf)                cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;            else                cout&lt;&lt;&quot;∞ &quot;;        }        cout&lt;&lt;&quot;\n&quot;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树小记</title>
      <link href="//articles/2018/08/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%B0%8F%E8%AE%B0/"/>
      <url>//articles/2018/08/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>线段树是一种二叉搜索树，时间复杂度为O(logN），它与二叉搜索树不同的是它的每一个节点表示的是一个区间的和，最小值，最大值等等（这要看题目如何要求了）。<br><a id="more"></a> </p><h3 id="啥是线段树呀？"><a href="#啥是线段树呀？" class="headerlink" title="啥是线段树呀？"></a>啥是线段树呀？</h3><p>线段树是一种二叉搜索树，它与二叉搜索树不同的是它的每一个节点表示的是一个区间的和，最小值，最大值等等（这要看题目如何要求了）。</p></blockquote><p>下图是一个表示区间和的线段树</p><p><img src="/08/线段树小记/1.jpeg" alt="1"></p><p>线段树支持区间修改，区间查询。<br>线段树节点的左儿子是它区间的左边一半，同理，右儿子是右边一半，当这个区间中的元素只有一个时，它就是叶子节点。</p><h3 id="线段树咋实现呀？"><a href="#线段树咋实现呀？" class="headerlink" title="线段树咋实现呀？"></a>线段树咋实现呀？</h3><p>我们有一个区间长度为n的线段树，有m次操作。</p><p>我们开一个数组z来存储线段树。</p><pre><code class="lang-cpp">const int maxn=1000005;int m,n,z[maxn]={};</code></pre><p>我们先来写一个建立求区间和的线段树函数</p><blockquote><p>l，r是当前区间的左右端点，rt是当前节点编号</p></blockquote><pre><code class="lang-cpp">void update(int rt){        z[rt] = z[rt*2] + z[rt*2+1];    //我们的线段是处理区间和的，所以我写了“+”；}void build(int l, int r,int rt) //建立一棵线段树{        if(l == r)              //当左端点=右端点时，就表示它是一个叶子节点，这时我们就给它赋值        {                int v;                scanf(&quot;%d&quot;,&amp;v);                z[rt]=v;                return;        }        int m=(l+r)/2;          //二分当前区间        build(lson);            //左边一段作为左子树，递归建立左子树        build(rson);            //右边一段作为右子树，递归建立右子树        update(rt);             //将左右子树的修改应用于当前节点}</code></pre><p>对于一个线段树，他的左儿子的区间一定是 l~m,右儿子一定是m~r，所以我们宏定义一下</p><pre><code class="lang-cpp">#define lson l,m,rt*2#define rson m+1,r,rt*2+1</code></pre><p>下面是查询区间和的函数</p><blockquote><p>findl表示要询问的区间的左端点，findr表示要询问的区间的右端点</p></blockquote><pre><code class="lang-cpp">#define lson l,m,rt*2#define rson m+1,r,rt*2+1int query(int l,int r,int rt,int findl,int findr)               //询问某段区间的和{        if(findl==l &amp;&amp; r==findr) return z[rt];                  //当前端点等于要找的端点时 返回        int m=(l+r)/2;                  //二分当前区间        if(findl&lt;=m) return query(lson,findl,findr);     //要找的区间在左子树上        else return query(rson,findl,findr);             //要找的区间在右子树上}</code></pre><p>问题来了，如果我们要找的区间在要找的区间贯穿左右子树时要怎么办呢？<br>比如说我们要求区间【4，7】的和。<br><img src="/08/线段树小记/3.jpeg" alt="3"></p><p>那我们就左右各查询一半吧！</p><p><img src="/08/线段树小记/2.jpeg" alt="2"></p><p>于是程序变成了。。。</p><pre><code class="lang-cpp">#define lson l,m,rt*2#define rson m+1,r,rt*2+1int query(int l,int r,int rt,int findl,int findr)       //询问某段区间的和{        if(findl==l &amp;&amp; r==findr) return z[rt];                  //当前端点等于要找的端点时 返回        int m=(l+r)/2;                  //二分当前区间        if(findl&lt;=m)                    //要找的区间在左子树上        {                if(m&lt;findr) return query(lson,findl,m)+query(rson,m+1,findr);   //特判：要找的区间贯穿左右子树                else return query(lson,findl,findr);        }        else return query(rson,findl,findr);    //要找的区间在右子树上}</code></pre><p>下面是修改区间的函数，和查询的函数有几分相似</p><pre><code class="lang-cpp">#define lson l,m,rt*2#define rson m+1,r,rt*2+1void modify(int l,int r,int rt,int findl,int findr,int v) //修改findl~findr区间的值，把它们都加上v{        if(l==r)                        //将区间的修改应用于它的每一个子节点        {                z[rt]+=v;                return;        }        int m=(l+r)/2;                  //二分当前区间        if(findl&lt;=m)                    //要修改的区间在左子树上        {                if(m&lt;findr)             //特判：要改的区间贯穿左右子树                {                        modify(lson,findl,m,v);         //在左子树上改findl~m这段                        modify(rson,m+1,findr,v);       //在右子树上改m+1~findr这段                }                else modify(lson,findl,findr,v);        }        else modify(rson,findl,findr,v);                //要找的区间在右子树上        update(rt);}</code></pre><p>下面是主程序：</p><pre><code class="lang-cpp">int main(){        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    //线段树区间的长度为n，有次操作        build(root);            //从根结点开始建立线段树        for(int i=1;i&lt;=m;i++)        {                int cmd;                scanf(&quot;%d&quot;,&amp;cmd);                switch(cmd)                {                        case 1:                 //修改线段树节点值                        int findl,findr,v;                        scanf(&quot;%d%d%d&quot;,&amp;findl,&amp;findr,&amp;v);                        modify(root,findl,findr,v);     //从根结点递归修改                        break;                        case 2:                 //询问线段树l~r区间的和                        int l,r;                        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);                        int re=query(root,l,r);                        printf(&quot;%d\n&quot;,re);                        break;                }        }        return 0;}</code></pre><p>对于一个线段树，他的根结点的区间一定是 1~n,编号一定是1，所以我们宏定义一下</p><pre><code class="lang-cpp">#define root 1,n,1</code></pre><p>自此，我们的朴素的线段树完工了。</p><p>代码：</p><pre><code class="lang-cpp">#include &lt;cstdio&gt;#define root 1,n,1#define lson l,m,rt*2#define rson m+1,r,rt*2+1const int maxn=1000005;int m,n,z[maxn]={};void update(int rt){    z[rt] = z[rt*2] + z[rt*2+1];    //我们的线段是处理区间和的，所以我们写了“+”；}void build(int l, int r,int rt) //建立一棵线段树{    if(l == r)        //当左端点=右端点时，就表示它是一个叶子节点，这时我们就给它赋值    {        int v;        scanf(&quot;%d&quot;,&amp;v);        z[rt]=v;        return;    }    int m=(l+r)/2;        //二分当前区间    build(lson);        //左边一段作为左子树，递归建立左子树    build(rson);        //右边一段作为右子树，递归建立右子树    update(rt);        //将左右子树的修改应用于当前节点}void modify(int l,int r,int rt,int findl,int findr,int v) //修改findl~findr区间的值，把它们都加上v{    if(l==r)            //将区间的修改应用于它的每一个子节点    {        z[rt]+=v;        return;    }    int m=(l+r)/2;            //二分当前区间    if(findl&lt;=m)            //要修改的区间在左子树上    {        if(m&lt;findr)        //特判：要改的区间贯穿左右子树        {            modify(lson,findl,m,v);        //在左子树上改findl~m这段            modify(rson,m+1,findr,v);    //在右子树上改m+1~findr这段        }        else modify(lson,findl,findr,v);    }    else modify(rson,findl,findr,v);        //要找的区间在右子树上    update(rt);}int query(int l,int r,int rt,int findl,int findr)        //询问某段区间的和 findl表示要询问的区间的左端点，findr表示要询问的区间的右端点{    if(findl==l &amp;&amp; r==findr) return z[rt];            //当前端点等于要找的端点时 返回    int m=(l+r)/2;            //二分当前区间    if(findl&lt;=m)            //要找的区间在左子树上    {        if(m&lt;findr) return query(lson,findl,m)+query(rson,m+1,findr);    //特判：要找的区间贯穿左右子树        else return query(lson,findl,findr);    }    else return query(rson,findl,findr);    //要找的区间在右子树上}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);     //线段树区间的长度为n，有次操作    build(root);         //从根结点开始建立线段树    for(int i=1;i&lt;=m;i++)    {        int cmd;        scanf(&quot;%d&quot;,&amp;cmd);        switch(cmd)        {            case 1:            //修改线段树节点值            int findl,findr,v;            scanf(&quot;%d%d%d&quot;,&amp;findl,&amp;findr,&amp;v);            modify(root,findl,findr,v);     //从根结点递归修改            break;            case 2:            //询问线段树l~r区间的和            int l,r;            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);            int re=query(root,l,r);            printf(&quot;%d\n&quot;,re);            break;        }    }    return 0;}</code></pre><p>我们来调个题试试。</p><p><a href="https://www.luogu.org/problemnew/show/P3372" target="_blank" rel="noopener">【模板】线段树 1</a></p><p>把程序提交上去，发现T了3个点</p><p>为神魔呢？</p><p>这里给大家一些时间思考</p><p><del>时间</del></p><p><del>时间</del></p><p><del>时间</del></p><p><del>时间</del></p><p><del>时间</del></p><p><del>时间</del></p><p><del>时间</del></p><p><del>时间</del></p><p><del>时间</del></p><p><del>时间</del></p><p><del>时间</del></p><p><del>时间</del></p><p>好惹，现在让我们<del>开倒车</del>回去，再看一遍我们的代码。</p><pre><code class="lang-cpp">#define lson l,m,rt*2#define rson m+1,r,rt*2+1void modify(int l,int r,int rt,int findl,int findr,int v) //修改findl~findr区间的值，把它们都加上v{    if(l==r)            //将区间的修改应用于它的每一个子节点    {        z[rt]+=v;        return;    }    int m=(l+r)/2;            //二分当前区间    if(findl&lt;=m)            //要修改的区间在左子树上    {        if(m&lt;findr)        //特判：要改的区间贯穿左右子树        {            modify(lson,findl,m,v);        //在左子树上改findl~m这段            modify(rson,m+1,findr,v);    //在右子树上改m+1~findr这段        }        else modify(lson,findl,findr,v);    }    else modify(rson,findl,findr,v);        //要找的区间在右子树上    update(rt);}</code></pre><p>你会发现<del>童话里都是骗人的</del>,我们的代蟆如果要修改一个区间，也会递归修改它的每一个子区间（子节点），但有时我们可能不查询它的子区间。这时我们就做了许多吴用公，于是，就有了线段树的一个叫【懒惰标记】的东西。</p><p>它的实现方法就是在修改区间的值时，不递归修改他的子区间，而是打一个标记，标记一下要修改多少，等到用户要访问它的子区间时，再现修改子区间。</p><p>代码如下：</p><pre><code class="lang-cpp">#define lson l,m,rt*2#define rson m+1,r,rt*2+1void add(int l,int r,int rt,int v)      //给l～r 编号为rt的区间加上v，同时打标记{    z[rt] += (r-l+1) * v;    flag[rt] += v;               //给它打一个v，为避免覆盖，这里是+=}void push_down(int l,int r,int rt)      //在询问时，把标记下放{    if(flag[rt] != 0)    {        int m=(l+r)/2;        add(lson,flag[rt]);  //打左儿子        add(rson,flag[rt]);  //打右儿子 233        flag[rt]=0;       //标记清零    }}</code></pre><p>同时，修改和查询的函数也要改一下</p><pre><code class="lang-cpp">#define lson l,m,rt*2#define rson m+1,r,rt*2+1#define now_node l,r,rtvoid modify(int l,int r,int rt,int findl,int findr,int v) //修改findl~findr区间的值，把它们都加上v{    if(findl&lt;=l &amp;&amp; r&lt;=findr)             //将区间的修改应用于它的每一个子节点    {        add(now_node,v);        return;    }    push_down(now_node);    int m=(l+r)/2;            //二分当前区间    if(findl&lt;=m)            //要修改的区间在左子树上    {        if(m&lt;findr)        //特判：要改的区间贯穿左右子树        {            modify(lson,findl,m,v);        //在左子树上改findl~m这段            modify(rson,m+1,findr,v);    //在右子树上改m+1~findr这段        }        else modify(lson,findl,findr,v);    }    else modify(rson,findl,findr,v);        //要找的区间在右子树上    update(rt);}int query(int l,int r,int rt,int findl,int findr)        //询问某段区间的和 findl表示要询问的区间的左端点，findr表示要询问的区间的右端点{    if(findl==l &amp;&amp; r==findr) return z[rt];        //当前端点等于要找的端点时 返回    push_down(now_node);    int m=(l+r)/2;            //二分当前区间    if(findl&lt;=m)            //要找的区间在左子树上    {        if(m&lt;findr) return query(lson,findl,m)+query(rson,m+1,findr);    //特判：要找的区间贯穿左右子树        else return query(lson,findl,findr);    }    else return query(rson,findl,findr);    //要找的区间在右子树上}</code></pre><p>主程序如下</p><blockquote><p>题目数据到了long long，所以主程序被我改了改</p></blockquote><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;#define root 1,n,1#define lson l,m,rt*2#define rson m+1,r,rt*2+1#define now_node l,r,rtconst int maxn=100005;long long m,n,z[maxn*4]={0},flag[maxn*4]={0};void update(int rt){    z[rt] = z[rt*2] + z[rt*2+1];    //我们的线段是处理区间和的，所以我们写了“+”；}void build(int l, int r,int rt) //建立一棵线段树{    if(l == r)        //当左端点=右端点时，就表示它是一个叶子节点，这时我们就给它赋值    {        int v;        cin&gt;&gt;v;        z[rt]=v;        return;    }    int m=(l+r)/2;        //二分当前区间    build(lson);        //左边一段作为左子树，递归建立左子树    build(rson);        //右边一段作为右子树，递归建立右子树    update(rt);        //将左右子树的修改应用于当前节点}void add(int l,int r,int rt,int v)      //给l～r 编号为rt的区间加上v，同时打标记{    z[rt] += (r-l+1) * v;    flag[rt] += v;               //给它打一个v，为避免覆盖，这里是+=}void push_down(int l,int r,int rt)      //在询问时，把标记下放{    if(flag[rt] != 0)    {        int m=(l+r)/2;        add(lson,flag[rt]);  //打左儿子        add(rson,flag[rt]);  //打右儿子 233        flag[rt]=0;       //标记清零    }}void modify(int l,int r,int rt,int findl,int findr,long long v) //修改findl~findr区间的值，把它们都加上v{    if(findl==l &amp;&amp; r==findr)             //将区间的修改应用于它的每一个子节点    {        add(now_node,v);        return;    }    push_down(now_node);    int m=(l+r)/2;            //二分当前区间    if(findl&lt;=m)            //要修改的区间在左子树上    {        if(m&lt;findr)        //特判：要改的区间贯穿左右子树        {            modify(lson,findl,m,v);        //在左子树上改findl~m这段            modify(rson,m+1,findr,v);    //在右子树上改m+1~findr这段        }        else modify(lson,findl,findr,v);    }    else modify(rson,findl,findr,v);        //要找的区间在右子树上    update(rt);}long long query(int l,int r,int rt,int findl,int findr)        //询问某段区间的和 findl表示要询问的区间的左端点，findr表示要询问的区间的右端点{    if(findl==l &amp;&amp; r==findr) return z[rt];        //当前端点等于要找的端点时 返回    push_down(now_node);    int m=(l+r)/2;            //二分当前区间    if(findl&lt;=m)            //要找的区间在左子树上    {        if(m&lt;findr) return query(lson,findl,m)+query(rson,m+1,findr);    //特判：要找的区间贯穿左右子树        else return query(lson,findl,findr);    }    else return query(rson,findl,findr);    //要找的区间在右子树上}int main(){    cin&gt;&gt;n&gt;&gt;m;           //线段树区间的长度为n，有次操作    build(root);         //从根结点开始建立线段树    for(int i=1;i&lt;=m;i++)    {        int cmd;        cin&gt;&gt;cmd;        switch(cmd)        {            case 1:            //修改线段树节点值            int findl,findr;            long long v;            cin&gt;&gt;findl&gt;&gt;findr&gt;&gt;v;            modify(root,findl,findr,v);     //从根结点递归修改            break;            case 2:            //询问线段树l~r区间的和            int l,r;            cin&gt;&gt;l&gt;&gt;r;            long long re=query(root,l,r);            cout&lt;&lt;re&lt;&lt;endl;            break;        }    }    return 0;}</code></pre><p>然后我们就A了。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 区间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧几里德算法（求最大公约数）</title>
      <link href="//articles/2018/08/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%AE%97%E6%B3%95/"/>
      <url>//articles/2018/08/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a> <h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>最大公约数Greatest Common Divisor(GCD)算法有好多种，这离我们介绍的是“欧几里德算法”，又名“辗转相除法”</p><h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><p>两个数的最大公因数 = 它们之中较小的那个数与它们较大的数 mod(取余”%”) 较小的数 的最大公因数</p><p>即 gcd(a,b) = gcd [min(a,b) , max(a,b) mod min(a,b)]</p><p>当a mod b = 0时，b便为我们要找的最大公约数</p><h3 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h3><blockquote><p>NOIP是不考证明的，有兴趣的童鞋可以了解一下</p><p>令a % b = r,<br>所以a = k × b + r,<br>所以r = a - k × b<br>假设d为a，b的一个公约数<br>那么 d|a，  d|b,（d|a的意思就是d整除a，也就是a能被d整除）<br>所以a - x × b 也一定能被d整除，即 d|r， 也就是 d|(a % b)<br>d也是b 和 (a % b)的公约数，因此a,b 的公约数和b, (a % b)的公约数也是一样的，其最大公约数也一定相同，所以gcd(a, b) = gcd(b, a % b);</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>非递归版</p><pre><code class="lang-cpp">inline int gcd(int a,int b){    if(a&lt;b) //如果a&lt;b 交换ab的值    {        int t=a;        a=b;        b=t;    }    while(b!=0)    {        int t=a%b;        a=b;        b=t;    }    return a;}</code></pre><p>递归版</p><pre><code class="lang-cpp">int gcd(int a,int b)  //调用前预处理如果a&lt;b 交换ab的值 确保a&gt;=b{    if(b == 0) return a; //当b = 0时，a便为我们要找的最大公约数 这时返回a的值便可    return gcd(b,a%b);}</code></pre><h3 id="模板题训练"><a href="#模板题训练" class="headerlink" title="模板题训练"></a>模板题训练</h3><p>最大公约数<a href="http://codevs.cn/problem/1212/" target="_blank" rel="noopener">http://codevs.cn/problem/1212/</a></p><p>最大公约数和最小公倍数问题(2001年NOIP全国联赛普及组)<a href="https://www.luogu.org/problemnew/show/P1029" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P1029</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集学习笔记</title>
      <link href="//articles/2018/07/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>//articles/2018/07/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>并查集是对集合进行查找与合并的一种数据结构<br><a id="more"></a> </p></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote><h5 id="luogu-P1551-亲戚"><a href="#luogu-P1551-亲戚" class="headerlink" title="luogu P1551 亲戚"></a><a href="https://www.luogu.org/problemnew/show/P1551" target="_blank" rel="noopener">luogu P1551 亲戚</a></h5><h5 id="时空限制"><a href="#时空限制" class="headerlink" title="时空限制"></a>时空限制</h5><p>1000ms / 128MB</p><h5 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h5><p>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。<br>题目描述<br>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h5><p>第一行：三个整数n,m,p，（n&lt;=5000,m&lt;=5000,p&lt;=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。<br>以下m行：每行两个数Mi，Mj，1&lt;=Mi，Mj&lt;=N，表示Mi和Mj具有亲戚关系。<br>接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。</p><h5 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h5><p>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。</p><h5 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h5><h6 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h6><p>6 5 3<br>1 2<br>1 5<br>3 4<br>5 2<br>1 3<br>1 4<br>2 3<br>5 6</p><h6 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h6><p>Yes<br>Yes<br>No</p></blockquote><p>很容易想到建立一个图论模型，然后dfs，但是这样时间复杂度太高，并查集是可以处理这样的任务的。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>并查集是对集合进行查找与合并的一种数据结构，一般用树实现。<br>并查集的操作分为两种：合并与查询</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/07/并查集学习笔记/1.png" alt="1"></p><p>我们可以开一个数组a[n]，其中a[i]表示第i个人的父节点是a[i]，<br>一开始，我们把每个人的父节点设为他们自己，即初始化a[i] = i。这时，所有人都可以理解为一个单独的个体，现在，我们开始合并亲戚，组成“家族”。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>我们合并1和2为亲戚，我们合并时选择让左边的数成为父节点，即a[2] = 1。</p><p><img src="/07/并查集学习笔记/2.png" alt="2"></p><p>合并1和5为亲戚，1为父节点，即a[5] = 1。</p><p><img src="/07/并查集学习笔记/3.png" alt="3"></p><p>合并3和4为亲戚，3为父节点，即a[4] = 3。</p><p><img src="/07/并查集学习笔记/4.png" alt="4"></p><p>合并5和2为亲戚，2为父节点，但我们发现2有了父节点，我们就递归寻找2，5的祖先节点，发现是一个，不合并。</p><p>合并1和3为亲戚，1为父节点，即a[3] = 1。</p><p><img src="/07/并查集学习笔记/5.png" alt="5"></p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>查找1和4，我们递归查找他们的祖先节点，同时将他们的每一个父节点和自己都直接连接他们的祖先节点（1本身就是祖先节点，所以直接返回他自己），以降低搜索复杂度（路径压缩），我们通过查找发现1，4的祖先节点是一个，输出“Yes”。</p><p><img src="/07/并查集学习笔记/6.png" alt="6"></p><p>查找2和3，我们递归查找他们的祖先（因为之前我们之前路径压缩过,所以可以很容易地搜索到），发现是一个祖先，输出“Yes”。</p><p>查找5和6，我们递归查找他们的祖先，找5返回1，找6返回6，发现不是一个，输出“No”。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><pre><code class="lang-cpp">#include &lt;cstdio&gt;int n, m, p, a[10001] = { 0 };    //a[i]表示i的祖先是a[i]int find(int x){    if (a[x] == x) return x;      //如果找到祖先，即a[x]=x（自己的祖先是自己），返回节点的值    //int a[x]的祖先 = find (a[x]);    //a[x] = a[x]的祖先;    //return a[x]的祖先;    return a[x] = find(a[x]);     //递归查找祖先并更改父节点们的祖先}void getf(int xi, int yi)        //合并xi,yi{    int xz = find(xi), yz = find(yi);    //找祖先    if (xz != yz) a[yz] = xz;}int main(){    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p);    for (int i = 1; i &lt;= n; i++) a[i] = i;    //初始化把每个人的父节点设为他们自己    int xi, yi;    for (int i = 1; i &lt;= m; i++)    {        scanf(&quot;%d%d&quot;, &amp;xi, &amp;yi);        getf(xi, yi); //合并xi,yi    }    for (int i = 1; i &lt;= p; i++)    {        scanf(&quot;%d%d&quot;, &amp;xi, &amp;yi);        if (find(xi) == find(yi))    //如果xi的祖先节点=yi的祖先节点            printf(&quot;Yes\n&quot;);        else printf(&quot;No\n&quot;);    }    return 0;}</code></pre><h3 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h3><p><a href="https://www.luogu.org/problemnew/show/P3367" target="_blank" rel="noopener">P3367 【模板】并查集</a></p><p><a href="https://www.luogu.org/problemnew/show/P1892" target="_blank" rel="noopener">P1892 [BOI2003]团伙</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL sort入坑笔记</title>
      <link href="//articles/2018/07/STL-sort/"/>
      <url>//articles/2018/07/STL-sort/</url>
      
        <content type="html"><![CDATA[<blockquote><p>先吐槽一句：sort真好用 qwq<br><a id="more"></a> </p></blockquote><p><a href="https://www.luogu.org/problemnew/show/P1177" target="_blank" rel="noopener">&gt;模板题&lt;</a></p><h3 id="sort是什么？"><a href="#sort是什么？" class="headerlink" title="sort是什么？"></a>sort是什么？</h3><p>sort是STL（Standard Template Library）中定义的一个函数，可以实现对某一个容器内的元素[i,j)进行排序，其内部使用快速排序实现，时间复杂度为o(nlongn)。</p><h3 id="sort如何使用？"><a href="#sort如何使用？" class="headerlink" title="sort如何使用？"></a>sort如何使用？</h3><h4 id="数组版："><a href="#数组版：" class="headerlink" title="数组版："></a>数组版：</h4><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;const int MAX = 100;int a[MAX] = {0}, n;int main(){    std::cin &gt;&gt; n;    for(int i = 1;i &lt;= n;i++) std::cin &gt;&gt; a[i];    std::sort(a+1,a+n+1); // 因为[i,j)，不包含j，所以n+1    //降序 std::sort(a+1,a+n+1,std::greater&lt;int&gt;());    for(int i = 1;i &lt;= n;i++) std::cout &lt;&lt; a[i] &lt;&lt;&quot; &quot;;    return 0;}</code></pre><h4 id="结构体版："><a href="#结构体版：" class="headerlink" title="结构体版："></a>结构体版：</h4><blockquote><p>这里提一句，sort内部是用 “ &lt; “ 来比较大小进行排序的，所以我们给结构体重载一个”&lt;”运算符，这叫<a href="https://blog.csdn.net/lishuzhai/article/details/50781753" target="_blank" rel="noopener">运算符重载</a>。</p></blockquote><p>实现智学网排名 ( • ̀ω•́ )✧<br>输入学生人数，年龄，成绩</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;struct peo{    string name;  //名称    int age;      //年龄    int data;     //成绩    bool operator&lt; (const peo &amp;b) const    {        return this-&gt;data &gt; b.data; //以成绩为排序依据,注意 是“&gt;”    }}a[100];int n;int main(){    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i].name &gt;&gt; a[i].age &gt;&gt; a[i].data;    sort(a + 1, a + n + 1);    for (int i = 1; i &lt;= n; i++)        cout &lt;&lt; i &lt;&lt; &quot;. &quot; &lt;&lt; a[i].name &lt;&lt; &quot; &quot; &lt;&lt; a[i].age &lt;&lt; &quot; &quot; &lt;&lt; a[i].data &lt;&lt; endl;    return 0;}</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>分数线划定<a href="https://www.luogu.org/problemnew/show/P1068" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P1068</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"Liu Zhe's Blog","short_name":"Liu Zhe's Blog","theme_color":"white","background_color":"white","display":"standalone","orientation":"portrait","scope":"/","start_url":"/","icons":[{"src":"images/icons/icon-72x72.png","sizes":"72x72","type":"image/png"},{"src":"images/icons/icon-96x96.png","sizes":"96x96","type":"image/png"},{"src":"images/icons/icon-128x128.png","sizes":"128x128","type":"image/png"},{"src":"images/icons/icon-144x144.png","sizes":"144x144","type":"image/png"},{"src":"images/icons/icon-152x152.png","sizes":"152x152","type":"image/png"},{"src":"images/icons/icon-192x192.png","sizes":"192x192","type":"image/png"},{"src":"images/icons/icon-384x384.png","sizes":"384x384","type":"image/png"},{"src":"images/icons/icon-512x512.png","sizes":"512x512","type":"image/png"}]}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>个人简历</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h4 id="欢迎来到liuzhe的Blog"><a href="#欢迎来到liuzhe的Blog" class="headerlink" title="欢迎来到liuzhe的Blog"></a>欢迎来到liuzhe的Blog</h4><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=103035&auto=1&height=66"></iframe><p><img src="https://apa.me/news/?s=6L+Z6YeM5pivbGl1emhl55qE5Y2a5a6iKGxpdS16aGUuZ2l0aHViLmlvKQ==" alt></p><p>liuzhe从六年级开始接触编程，给MC用Python写插件，初中一年级开始转C++，开始学Linux和Qt，主要搞创客这一块的东西，到了初二才知道有OI这个神奇的东西，阴差阳错地过了NOIP2017初赛，混了个三等奖，liuzhe在OJ的题海中“怅”游，A掉的题屈指可数。总之很菜就对了。</p><p>已死在NOIP2018,珍爱生命，杜绝棉花tang,吃棉花糖吃死了（</p><p>于CSP2019之后退役，发挥失误得了省三。</p><p><font color="#e20f0f" size="4"><center>仰望星空的人</center><front></front></font></p><p><font color="#ff9e1d" size="4"><center>总以为星星就是宝石</center><front></front></font></p><p><font color="#f2ff01" size="4"><center>晶莹、透亮，没有纤瑕</center><front></front></font></p><p><font color="#00EEC0" size="4"><center>飞上星空的人知道</center><front></front></font></p><p><font color="#11CCFF" size="4"><center>那儿有灰尘、石渣</center><front></front></font></p><p><font color="#AA00FF" size="4"><center>和地球一样复杂 </center><front></front></font></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/link.js"/>
      <url>/js/link.js</url>
      
        <content type="html"><![CDATA[link = {  init: function () {    var that = this;    //这里设置的是刚才的 linklist.json 文件路径    $.getJSON("/links/linklist.json", function (data) {      that.render(data);    });  },  render: function (data) {    var html, nickname, avatar, site, li = "";    for (var i = 0; i < data.length; i++) {      nickname = data[i].nickname;      avatar = data[i].avatar;      site = data[i].site;      li += '<div class="card">' +        '<a href="' + site + '" target="_blank">' +        '<div class="thumb" style="background: url( ' + avatar + ');">' +        '</div>' +        '</a>' +        //href 和 src 的链接地址是相册照片外部链接，也可以放博客目录里        '<div class="card-header">' +        '<div><a href="' + site + '" target="_blank">' + nickname + '</a></div>' +        '</div>' +        '</div>';    }    $(".link-navigation").append(li);  }}link.init();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
